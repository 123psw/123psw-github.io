{"meta":{"title":"平湖烟雨","subtitle":"爆炒三文鱼","description":"","author":"潘苏皖","url":"https://pan_su_wan.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-07T09:40:13.000Z","updated":"2020-04-07T09:41:48.359Z","comments":true,"path":"categories/index.html","permalink":"https://pan_su_wan.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-07T09:42:26.000Z","updated":"2020-04-07T09:43:14.944Z","comments":true,"path":"tags/index.html","permalink":"https://pan_su_wan.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于NUCLEO-WB55开发板对代码进行解析以及实现","slug":"基于NUCLEO-WB55开发板对代码进行解析以及实现","date":"2020-12-27T05:41:33.000Z","updated":"2020-12-27T10:10:27.473Z","comments":true,"path":"posts/wb55/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/wb55/","excerpt":"","text":"实验目的本文利用STM32CubeMx初始化配置STM32WB55,使用自己生成的顾客服务与特性实现蓝牙之间的读写通知，通过写控制LED2亮灭，读取LED1的状态，通知LED3（300ms闪烁）来实现本实验的目的。 实验环境 STM32CubeMx V6.1.0 , KeilMDK V5.33.0.0 ,ST BLE Sensor v4.6.1 (安卓版本) ， WireShark V3.4.0 NUCLE-WB55.Nucleo开发板 STM32WB55参考手册 , NUCLE-WB55.Nucleo开发板原理图 注意 : 要实现程序的下载 PC端需要安装STMicroelectronics stlink-server这个驱动 硬件架构实现 STM32WB55主要特性：2颗独立内核，CPU1主要是用户需求，通俗的讲，接收到的数据该如何去用。比如当客户端（ST BLE Sensor）写数据，服务器（NUCLE-WB55.Nucleo）将数据接收到，我们将接收到的数据进行利用。本文利用客户端写入0x01和0x00实现开发板上的LED2亮灭；CPU2的功能就是一个蓝牙芯片，例如Cannon的Bluenrg。 处理器间的通信：处理器间的通信是通过处理器间通信控制器 (IPCC)来实现的。IPCC主要特性： 12 个通道传输状态信号 每个处理器有两条中断线 按通道屏蔽中断 两种通道工作模式通过STM32WB55参考手册可知,CPU1和CPU2之间通过IPCC的RX和TX中断实现的。因此在编写代码过程中需使用到这两个中断。 软件架构的实现本文通过STM32CubeMx生成,利用HAL库实现。 打开KeilMOK,在maim.c文件下可以看到一些初始化： HAL_Init(); //重置所有外围设备，初始化Flash接口和Systick。 SystemClock_Config(); //配置系统时钟 MX_GPIO_Init(); //初始化IO口 MX_RF_Init(); //初始化RF,由于RF由于CPU2来控制的，因此在这里不配置，因此此函数为空 MX_RTC_Init(); //初始化RTC MX_TIM2_Init(); //初始化定时器 APPE_Init(); //STM32_WPAN的初始化代码本文主要是实现蓝牙通信，因此APPE_Init这个函数就是用来对蓝牙进行相关的操作。进入APPE_Init可以看到; SystemPower_Config(); //配置系统电源模式 HW_TS_Init(hw_ts_InitMode_Full, &amp;hrtc); //初始化TimerServer BSP_LED_On(LED1); //顾客函数，相当于只要进入此函数，LED1点亮。 appe_Tl_Init(); //初始化所有传输层 return;前面三个函数不必过于纠结，在本文本中还用不到理解，主要是appe_Tl_Init这个函数: TL_MM_Config_t tl_mm_config; SHCI_TL_HciInitConf_t SHci_Tl_Init_Conf; /**&lt; Reference table initialization */ TL_Init(); /**&lt; System channel initialization */ UTIL_SEQ_RegTask( 1&lt;&lt; CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, shci_user_evt_proc ); SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&amp;SystemCmdBuffer; SHci_Tl_Init_Conf.StatusNotCallBack = APPE_SysStatusNot; shci_init(APPE_SysUserEvtRx, (void*) &amp;SHci_Tl_Init_Conf); /**&lt; Memory Manager channel initialization */ tl_mm_config.p_BleSpareEvtBuffer = BleSpareEvtBuffer; tl_mm_config.p_SystemSpareEvtBuffer = SystemSpareEvtBuffer; tl_mm_config.p_AsynchEvtPool = EvtPool; tl_mm_config.AsynchEvtPoolSize = POOL_SIZE; TL_MM_Init( &amp;tl_mm_config ); TL_Enable(); return;这里不过多解释，后面还会讲到这里，这里主要是APPE_SysUserEvtRx这个函数: static void APPE_SysUserEvtRx( void * pPayload ) { UNUSED(pPayload); APPD_EnableCPU2( ); //使能CPU2 APP_BLE_Init( ); //初始化BLE各层 UTIL_LPM_SetOffMode(1U &lt;&lt; CFG_LPM_APP, UTIL_LPM_ENABLE); return; }这个函数的作用就是实现CPU2使能，以及BLE各层初始化，这边也不过多解释，后面将会介绍。这样主函数初始化就结束了，程序从现在开始，就会等待就绪事件（VS_HCI_C2_Ready）。 while(1)循环函数。在while(1)循环函数可以看到只用了一个函数 UTIL_SEQ_Run，看到这里估计会有些蒙。其实这里用到了调度器。这个时候就开始用到之前没有讲到的地方了。UTIL_SEQ_RegTask和 UTIL_SEQ_SetTask。UTIL_SEQ_RegTask这个函数类似于登记，UTIL_SEQ_SetTask类似于操作系统的信号量。比如上文中看到UTIL_SEQ_RegTask( 1&lt;&lt; CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, shci_user_evt_proc );以及在app_entry.c文件末尾出可以找到shci_notify_asynch_evt这个函数，它包含了UTIL_SEQ_SetEvt( 1&lt;&lt; CFG_IDLEEVT_SYSTEM_HCI_CMD_EVT_RSP_ID );这个函数。从这里可以看出这两个函数： UTIL_SEQ_SetEvt( 1&lt;&lt; CFG_IDLEEVT_SYSTEM_HCI_CMD_EVT_RSP_ID ); UTIL_SEQ_RegTask( 1&lt;&lt; CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, shci_user_evt_proc );通俗的来讲，当程序进入到UTIL_SEQ_SetEvt( 1&lt;&lt; CFG_IDLEEVT_SYSTEM_HCI_CMD_EVT_RSP_ID );这个函数里，UTIL_SEQ_Run这个函数就会找到UTIL_SEQ_RegTask( 1&lt;&lt; CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, shci_user_evt_proc );这个函数下的shci_user_evt_proc函数，最终程序执行shci_user_evt_proc函数里的东西。 蓝牙连接所使用的函数在custom_stm.c文件下，Custom_STM_Event_Handler函数就是对事件的处理,以下case语句就是Custom_STM_Event_Handler的部分代码，通过接收到的读写通知事件执行相关程序。 case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED: /* USER CODE BEGIN EVT_BLUE_GATT_ATTRIBUTE_MODIFIED */ attribute_modified = (aci_gatt_attribute_modified_event_rp0*)blue_evt-&gt;data; if(attribute_modified-&gt;Attr_Handle == (CustomContext.CustomShortledserviceHdle + 4)) { return_value = SVCCTL_EvtAckFlowEnable; if(attribute_modified-&gt;Attr_Data[0] &amp; COMSVC_Notification) { Notification.Custom_Evt_Opcode = CUSTOM_STM_SHORTREADANDWRITEORNOTICECHAR_NOTIFY_ENABLED_EVT; Custom_STM_App_Notification(&amp;Notification); } else { Notification.Custom_Evt_Opcode =CUSTOM_STM_SHORTREADANDWRITEORNOTICECHAR_NOTIFY_DISABLED_EVT; Custom_STM_App_Notification(&amp;Notification); } } /* USER CODE END EVT_BLUE_GATT_ATTRIBUTE_MODIFIED */ break; case EVT_BLUE_GATT_READ_PERMIT_REQ : /* USER CODE BEGIN EVT_BLUE_GATT_READ_PERMIT_REQ */ read_perm_req = (aci_gatt_read_permit_req_event_rp0 *)blue_evt-&gt;data; if(read_perm_req-&gt;Attribute_Handle == (CustomContext.CustomShortledserviceHdle + 2)) { return_value = SVCCTL_EvtAckFlowEnable; Notification.Custom_Evt_Opcode = CUSTOM_STM_SHORTREADANDWRITEORNOTICECHAR_READ_EVT; Custom_STM_App_Notification(&amp;Notification); aci_gatt_allow_read(read_perm_req-&gt;Connection_Handle); } /* USER CODE END EVT_BLUE_GATT_READ_PERMIT_REQ */ break; case EVT_BLUE_GATT_WRITE_PERMIT_REQ: /* USER CODE BEGIN EVT_BLUE_GATT_WRITE_PERMIT_REQ */ write_perm_req = (aci_gatt_write_permit_req_event_rp0*)blue_evt-&gt;data; if( write_perm_req-&gt;Attribute_Handle == (CustomContext.CustomShortledserviceHdle + 2)) { return_value = SVCCTL_EvtAckFlowEnable; Notification.Custom_Evt_Opcode = CUSTOM_STM_SHORTREADANDWRITEORNOTICECHAR_WRITE_NO_RESP_EVT; Notification.DataTransfered.Length=write_perm_req-&gt;Data_Length; Notification.DataTransfered.pPayload=write_perm_req-&gt;Data; aci_gatt_write_resp(write_perm_req-&gt;Connection_Handle,write_perm_req-&gt;Attribute_Handle,0,0,write_perm_req-&gt;Data_Length,write_perm_req-&gt;Data); Custom_STM_App_Notification(&amp;Notification); } /* USER CODE END EVT_BLUE_GATT_WRITE_PERMIT_REQ */ break;在通知过程中，本文利用TIM2定时器。每隔100ms发送通知，因此在定时器的回调函数中添加UTIL_SEQ_SetTask标志，在 APP_BLE_Init函数中添加UTIL_SEQ_SetTask函数。这里就不过多介绍。 实验步骤STM32CubeMx配置 软件设计 软件设计视频中少添加了 attribute_modified = (aci_gatt_attribute_modified_event_rp0*)blue_evt->data，因此无法通知，可以参考下面例程。 资料百度网盘链接：https://pan.baidu.com/s/1r8_FHHor-gnewPku_j2hmQ提取码：9g0g","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"基于Cannon小钢炮蓝牙通信添加服务与特性","slug":"基于Cannon小钢炮蓝牙通信","date":"2020-12-18T06:33:11.000Z","updated":"2020-12-20T09:58:48.829Z","comments":true,"path":"posts/swble/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/swble/","excerpt":"","text":"实验目的本文主要目的是添加服务与特性，在BLE Scanner中实现读，写，通知。 实验环境 软件: stm32cubemx ,keilMDK，BLE Scanner, WireShark 硬件：Cannon小钢炮 资料：BlueNRG-1、BlueNRG-2 BLE 栈 v2.x 编程指南 实验步骤STM32CubeMx配置 软件设计蓝牙协议栈要实现蓝牙之间的通信，首先得知道蓝牙之间如何进行通信的。一般而言，我们把某个协议的实现代码称为协议栈，BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。接下来对BLE协议进行简单介绍。简单来说，BLE协议栈主要用来对应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。蓝牙协议规定了两个层次的协议，分别为蓝牙核心协议（Bluetooth Core）和蓝牙应用层协议（Bluetooth Application）。而蓝牙核心协议（Bluetooth Core）又包含BLE Controller和BLE Host两部分。 BLE低功耗蓝牙核心协议层通用访问配置文件层(GAP) ：它定义了设备如何彼此发现，建立连接以及如何实现绑定，同时描述了设备如何成为广播者和观察者，实现无需连接的数据传输，并且定义了如何用不同类型的地址来实现隐私性和可解性。也就是说它定义了一个蓝牙设备所需具备的基本要求。通用属性配置文件层（GATT）：GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。他定义了使用ATT协议的框架，被用于服务，特征，描述符发现，特征读写，写入，指示和通知。属性协议层（ATT）：简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。安全管理层(SM):当两个设备要在连接期间进行通信加密时，安全管理器使用配对流程。此流程允许通过交换身份信息来验证两个设备，交换信息是为了创建可作为受信任关系或（单个）安全连接基础的安全密钥。有一些方法用于执行配对过程。逻辑链路控制及自适应协议层(L2CAP):支持更高层协议复用、数据包分割和重组操作以及服务信息质量的通知。主机控制器接口（HCI）：主机和控制器之间提供了一种通信方式。本文使用的SPI接口实现HOST与Control的连接。链路层（LL）：LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。LL层要做的事情非常多，比如具体选择哪程度 个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。物理层（PHY）：PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。 添加服务与特性 打开keilMDK，找到gatt_db.c文件，添加服务与特性的UUID，定义服务与特性句柄#define COPY_USART1_SERVICE_UUID(uuid_struct) COPY_UUID_128(uuid_struct,0x00,0x00,0x00,0x00,0x00,0x03,0x11,0xe1,0x9a,0xb4,0x00,0x02,0xa5,0xd5,0xc5,0x1b) #define COPY_SEND_AND_RECEIVE_CHAR_UUID(uuid_struct) COPY_UUID_128(uuid_struct,0x01,0x00,0x00,0x00,0x00,0x01,0x11,0xe1,0x9a,0xb4,0x00,0x02,0xa5,0xd5,0xc5,0x1b) uint16_t UTServW2STHandle, SendandreceiveCharHadle; 要实现添加服务，首先得知道这几个函数：aci_gatt_add_serv功能是将服务添加到GATT服务器中，入口参数如下： tBleStatus aci_gatt_add_serv(uint8_t service_uuid_type, //服务类型UUID（16位或128位） const uint8_t* service_uuid, //基于UUID类型字段的16位或128位UUID uint8_t service_type, //主要或辅助服务 uint8_t max_attr_records, //添加到此服务的最大属性记录数（包括服务声明本身） uint16_t *serviceHandle); //务的句柄。将此服务添加到服务后，服务器将句柄分配给该服务。服务器也将此服务的句柄范围从serviceHandle分配给&lt;serviceHandle + max_attr_records&gt;。 aci_gatt_add_char功能是为服务添加特征。入口参数如下： tBleStatus aci_gatt_add_char(uint16_t serviceHandle, //向其添加特征的服务的句柄。 uint8_t charUuidType, //特征UUID的类型（16位或128位）。 const uint8_t* charUuid, //16位或128位UUID uint8_t charValueLen, //特征值的最大长度 uint8_t charProperties, //特征属性, uint8_t secPermissions, //添加的特征的安全权限 uint8_t gattEvtMask, //位掩码，用于启用将由GATT服务器发送到应用程序的事件 uint8_t encryKeySize, //此属性的最小加密密钥大小要求。有效范围：7到16。 uint8_t isVariable, //如果属性具有可变长度值字段（1）或没有（0）。 uint16_t* charHandle); //已添加特征的句柄。它是特征声明的句柄。在gatt_db.c文件中，添加自己所写的服务与特性，在初始化过程中添加此函数，实现服务与特性的添加。代码如下： tBleStatus Add_USARTServW2ST_Service(void) { tBleStatus ret; int32_t NumberOfRecords=1; uint8_t uuid[16]; COPY_USART1_SERVICE_UUID(uuid); BLUENRG_memcpy(&amp;service_uuid.Service_UUID_128, uuid, 16); ret = aci_gatt_add_serv(UUID_TYPE_128, service_uuid.Service_UUID_128, PRIMARY_SERVICE, 1+3*NumberOfRecords, &amp;UTServW2STHandle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } COPY_SEND_AND_RECEIVE_CHAR_UUID(uuid); BLUENRG_memcpy(&amp;char_uuid.Char_UUID_128, uuid, 16); ret = aci_gatt_add_char(UTServW2STHandle, UUID_TYPE_128, char_uuid.Char_UUID_128, 2+4+2, CHAR_PROP_NOTIFY|CHAR_PROP_READ|CHAR_PROP_WRITE, ATTR_PERMISSION_NONE, GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP|GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP|GATT_NOTIFY_ATTRIBUTE_WRITE, 16, 1, &amp;SendandreceiveCharHadle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } return BLE_STATUS_SUCCESS; fail: return BLE_STATUS_ERROR; } 在sensor.c文件中添加属性事件。user_notify函数功能作用是回调处理ACI事件。在 case EVT_VENDOR:语句中，是对属性进行判断。EVT_BLUE_GATT_READ_PERMIT_REQ是GATT读允许请求，EVT_BLUE_GATT_WRITE_PERMIT_REQ为GATT写允许请求，EVT_BLUE_GATT_ATTRIBUTE_MODIFIED为GATT通知。当客户端对服务器进行读，写，通知时，程序将进入此函数进行相关操作。 case EVT_VENDOR: { evt_blue_aci *blue_evt = (void*)event_pckt-&gt;data; switch(blue_evt-&gt;ecode){ case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED: { evt_gatt_attr_modified_IDB05A1 *nt = (void*)blue_evt-&gt;data; //uint8_t a = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_3); //aci_gatt_update_char_value_ext_IDB05A1(nt-&gt;conn_handle,nt-&gt;attr_handle,0x01,4,6,2,&amp;a); } break; case EVT_BLUE_GATT_READ_PERMIT_REQ: { evt_gatt_read_permit_req *pr = (void*)blue_evt-&gt;data; Read_Request_CB(pr-&gt;attr_handle); } break; case EVT_BLUE_GATT_WRITE_PERMIT_REQ: { evt_gatt_write_permit_req *pw = (void*)blue_evt-&gt;data; Write_Request_CB(pw); } break; } } break; } 对相应的属性做出响应。在EVT_BLUE_GATT_READ_PERMIT_REQ中，进入Read_Request_CB函数，添加的读属性进行操作，本文将0x1234发送给客户端。 else if(handle == SendandreceiveCharHadle + 1) { BlueMS_Sendandreceive_Update(0x12345678, 0x1234); }BlueMS_Sendandreceive_Update函数功能为将服务器中的数据发送给客户端，代码如下： //更新数据 tBleStatus BlueMS_Sendandreceive_Update(int32_t press, int16_t temp) { tBleStatus ret; uint8_t buff[2]; HOST_TO_LE_16(buff, HAL_GetTick()&gt;&gt;3); //HOST_TO_LE_32(buff+2,press); HOST_TO_LE_16(buff,temp); ret = aci_gatt_update_char_value(UTServW2STHandle, SendandreceiveCharHadle, 0, 2, buff); if (ret != BLE_STATUS_SUCCESS){ PRINTF(&quot;Error while updating TEMP characteristic: 0x%04X\\n&quot;,ret) ; return BLE_STATUS_ERROR ; } return BLE_STATUS_SUCCESS; }在EVT_BLUE_GATT_WRITE_PERMIT_REQ中，添加Write_Request_CB函数，客户端写数据时，程序将进入这里，服务器进行读取进行相关操作，本函数只是从客户端写入的数据放入dubf数组中，没有进行相关操作，代码如下： void Write_Request_CB(evt_gatt_write_permit_req *pw) { tBleStatus ret; uint8_t dubf[4]; if(connection_handle !=0) { ret = aci_gatt_write_response(pw-&gt;conn_handle,pw-&gt;attr_handle,0,0,pw-&gt;data_length,pw-&gt;data); if (ret != BLE_STATUS_SUCCESS) { PRINTF(&quot;aci_gatt_allow_read() failed: 0x%02x\\r\\n&quot;, ret); } } if(pw-&gt;attr_handle == AccGyroMagCharHandle + 1) { } else if (pw-&gt;attr_handle == EnvironmentalCharHandle + 1) { } else if(pw-&gt;attr_handle == SendandreceiveCharHadle + 1) { dubf[0] = pw-&gt;data[0]; dubf[1] = pw-&gt;data[1]; dubf[2] = pw-&gt;data[2]; dubf[3] = pw-&gt;data[3]; } }在通知属性中，当将新值写入启用通知的特性时，服务器将启动此操作。如果客户端已订阅有关该特征的通知，则在写入新值时会将新值推送到客户端。本文是将LED的状态通知给客户端。在app_bluenrg_ms.c下，在User_Process中，connected判断语句下添加以下两行代码： uint8_t a = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_3); BlueMS_LED_Update(a);BlueMS_LED_Update函数作是更新客户端的值,代码如下： tBleStatus BlueMS_LED_Update(int8_t led) { tBleStatus ret; uint8_t buff[2]; HOST_TO_LE_16(buff, HAL_GetTick()&gt;&gt;3); HOST_TO_LE_16(buff,led); ret = aci_gatt_update_char_value(UTServW2STHandle, SendandreceiveCharHadle, 0, 2, buff); if (ret != BLE_STATUS_SUCCESS){ PRINTF(&quot;Error while updating LED characteristic: 0x%04X\\n&quot;,ret) ; return BLE_STATUS_ERROR ; } return BLE_STATUS_SUCCESS; }至此，这个程序就实现了添加服务与特性，以及读写通知属性。 实验结果本文使用BLE Scanner作为客户端。当BLE Scanner和Cannon小钢炮相连时，读取数据，写入数据，以及通知。如图1-1所示，为wireshark抓到的包，客户端读取的数据，也就是服务器发送的数据。如图1-2所示，为wireshark抓到的写入数据包。如图1-3所示，为wireshark抓到的通知包。","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"关于智能小车电机的选取","slug":"关于智能小车电机的选取","date":"2020-05-31T04:52:47.000Z","updated":"2020-05-31T12:15:57.928Z","comments":true,"path":"posts/906927798/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/906927798/","excerpt":"","text":"挑选智能小车的电机功以及功率的理解功是物理学中表示力对位移的累积的物理量。功率是指物体在单位时间内所做的功的多少，即功率是描述做功快慢的物理量。 直流伺服马达挑选直流伺服马达有以下条件 计算所需的最大功率 利用功率需求挑选合适的马达 利用力矩与速度需求挑选合适的齿轮比假设最大加速度为7m/s2，最大的速度为3m/s,智能小车的重量为0.13kg,那么两个电机的功率为：P=FV=maV=0.13 x 7 x 3 = 2.73W;则一个电机的功率为1.365W。所以最大输出功率必须超过1.365W。假设轮直径为25mm,则F=ma=0.13 X 7 = 0.91N,所以力矩为0.91 X 12.5 / 2 = 5.6875mNm,要让智能小车达到3m/s的速度，马达所需的转速是3000mm/s/(3.14 X 25mm/转) = 38.2转/s = 2292rpm。","categories":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/categories/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}],"tags":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}]},{"title":"红外传感器距离与电压对数函数的由来","slug":"关于红外传感器输出电压和迷宫墙距离函数关系研究","date":"2020-05-31T02:03:51.000Z","updated":"2020-05-31T04:57:26.195Z","comments":true,"path":"posts/2339799628/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/2339799628/","excerpt":"","text":"材料 stm32F401RET6小刚炮 OSE-1L7，2SC3325资料 OSE-1L7数据手册 2SC3325数据手册 TSL262R数据手册红外线发射接收端电路如图1-1所示，为红外线发射接收端电路。VB为stm32F401RET6的引脚控制端。PS为8.4V的电压。由于stm32F401RET6的引脚输出电压为3.3V,而VBE的压降约为0.8V所以Ib的计算方式为：从OSE-1L1数据手册中可以找到额定电压为1.35V，额定电流为100mA,所以Vce电压为：Vce = 8.4V-(5x1.35V) = 1.65V如图1-2所示，当Ib=0.5mA,Vce=1.65V时，IC电流约为90mA,符合OSE-1L1的额定电流。 OSE-1L7分析从数据手册中可以看到，发出红外线波长集中在940nm(图2-1)，而且在顺向电流50mA时，发射光强度为50mW/sr，同时超过10度以外，发射光的强度相对正前方下降至一半以下(图2-2)。从图2-3可以看出超过50mW/sr的用虚线表示，但前面估算出90mA的顺向电流，因此可以估测会有以下的发射量：球面度球面度是一个立体角的计量单位。面积为半径平方(r2)的球表面对球心的张角等于1球面度。因此可以将发射强度为90mW/sr换算为(90/r2)mW/cm2=(90000/r2)uW/cm2。 TSL262R分析TSL262R为红外线接收端，从数据手册中看出可以接收940nm的红外线波长。如图4-1所示，光感测器TSL262R输出电压与接收光能量强度图形，可以写出下列函数公式：我们OSE-1L7分析中将(90000/r2)uW/cm2值代入这个函数中可以算出在某一距离下TSL262R输出电压值：但是由于不同的电路，发射强度不一定时90mW/sr,而且还要一些其他因素。假设输出电压与接收光能量强度的线性关系不会因为这些情况影响。那么我们可以写成下面的公式：也可以改写为：其中Z代表着OSE-1L7发射强度以及一些其他影响，r表式距离。那么最终可以写成距离和电压的对数数学公式：","categories":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/categories/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}],"tags":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}]},{"title":"fritzing软件的使用","slug":"fritzing软件的使用","date":"2020-05-04T11:23:33.000Z","updated":"2020-05-05T06:22:12.197Z","comments":true,"path":"posts/3908916139/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/3908916139/","excerpt":"","text":"fritzing是什么 Fritzing是一项开放源代码的硬件计划，该计划使电子产品可以作为任何人的创意材料来使用。我们本着Processing和Arduino的精神提供软件工具，社区网站和服务，建立了一个创新的生态系统，允许用户记录其原型，与他人共享它们，在教室里教电子产品以及布置和制造专业的PCB 。 软件下载地址 提取码：d9ui fritzing的操作 资料驱动资料 提取码：ropy","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"串口数据可视化","slug":"串口可视化","date":"2020-04-26T10:11:24.000Z","updated":"2020-05-05T06:20:26.337Z","comments":true,"path":"posts/1642934042/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1642934042/","excerpt":"","text":"实验目的实现串口接收数据可视化。 实验材料软件：多功能串行口调试助手硬件：stm32103开发板 实验现象 实验步骤本文使用基于stm32f103任意发送字符串-中级中的代码，实现串口接收数据可视化。 将开发板插入电脑。 如图2-1所示，打开多功能串行口调试助手，进行串口参数配置，然后打开串口。 如图3-1所示，勾线曲线绘制使能。 发送字节。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"基于串口接收——keil图形化仿真","slug":"keil图形化仿真","date":"2020-04-23T00:26:20.000Z","updated":"2020-04-23T09:22:22.329Z","comments":true,"path":"posts/1626806820/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1626806820/","excerpt":"","text":"实验目的将串口助手收到字符用图形化显示出来。 实验资料 keilMDK，Configure Virtual Serial Port Driver，串口助手 硬件：stm32f103开发版实验现象实验步骤Logic Analyzer 介绍在keil中软件逻辑分析仪（logic analyzer）很强的功能，可以分析数字信号，模拟化的信号，CPU的总线(UART、IIC等一切有输出的管脚)，提供调试函数机制。本文使用Logic Analyzer实现将接收到的字符用图形化显示出来。 操作方法 如图2-1所示，点击Options for Target…出现窗口，接下来点击Target,在Xtal(MHz)配置仿真时时钟的大小。 如图2-2所示，点击Debug窗口，选择Use Simulator和Limit Speed to Real-Time实现软件仿真，最后点击OK。 如图2-3所示，点击Start/Stop Debug Session进入仿真模式，然后选择Logic Analyzer,在Logic Analyzer窗口下点击Setup…添加所需仿真的变量（图2-4对Setup的设置），最后点击Run运行代码。 如图2-4所示，点击New(Insert)，添加所需仿真的变量。本文是实现将串口助手收到字符用图形化显示出来，因此将ch变量添加进去。注意事项Logic Analyzer添加所需仿真变量必须是全局变量，否在无法添加。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"基于Matlab中数据拟合实现红外传感器值与距离的关系","slug":"基于Matlab中数据拟合实现传感器值与距离的关系","date":"2020-04-22T04:20:24.000Z","updated":"2020-04-25T03:56:51.865Z","comments":true,"path":"posts/1867721103/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1867721103/","excerpt":"","text":"什么是数据拟合 数据拟合又称曲线拟合，俗称拉曲线，是一种把现有数据透过数学方法来代入一条数式的表示方式。科学和工程问题可以通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合(fitting)。 举个简单拿到例子，函数y=x（x属于R）;每一个x的值都有一个y值。假设需要采样某个器件在不同种条件下得到不同种的值，就好比在自变量x下得到得到应变量y。当无法采样时，该如何，这个时候就在这些数据中找规律。一旦规律找出来，就可以在无法采样时找到这个值。当然，这个时候这个值并不准确，当采样的数据越多，那么在曲线规律下值就越准确，这样在曲线规律预测的这个值就更加精确实际测量到的值，这就是数据拟合。 数据拟合的意义数据拟合在很多地方都有着重大意义。比如预测，估算。总的来说有以下两点： 总结事件发生的规律 规律属于何种本文数据拟合的意义在于实现智能小车在墙迷宫走迷宫时，将传感器接收到的数据经过数据拟合得到墙壁与传感器的距离进行判断实现循迹和判断迷宫路口，那么首先应该实现红外传感器接收到的值和距离进行数据拟合。 传感器值与距离的数据拟合红外线传感器工作原理首先，实现传感器值与距离的数据拟合是为了CPU读取了传感器的值，从而知道自己所在的位置，以便于CPU准确的做出下一步指令。传感器的值是如何获取的呢？这里大致解释一下红外线的工作原理。红外线由两部分构成，接收管和发射管。发射管接通电源后，发射红外线。当障碍物的位置不同，反射的红外线大小也不同，当然障碍物的颜色也对红外线反射有影响。反射的红外线将会被传感器的接收管检测到。而接收管类似于变阻器，不过电阻的大小由反射红外线大小控制；而电阻的大小我们不能检测到，但可以检测到接收管的电压。因此看电压的大小可以知道反射红外线的大小。。当然如果没有障碍物时，接收管就无法接收到反射的红外线。 红外传感器函数公式红外传感器有一个函数公式，logv = clogr + d。这里的公式本文不做解释，后期向大家介绍。 最小二乘法本文使用最小二乘法求出c,d的值。那么什么是最小二乘法？ 最小二乘法，是一种数学优化方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便的求得未知的数据，并使得求得的数据与实际数据之间误差的平方和为最小。 理解从函数微积分角度：假设某次实验得到了四个数据点(x, y)：(1,6)、(2,5)、(3,7)、(4,10)，我们希望找出一条和这四个点最匹配的直线 y=a+bx，即找出在某种“最佳情况”下能够大致符合如下超定线性方程组的a和b:a + 1b = 6;a + 2b = 5;a + 3b = 7;a + 4b = 10;最小二乘法就是求出(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b))的最小值。那我们就设最小值为z,则：z=(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b));因为平方了，因此z恒大于等于0。同时可以知道，z是不可能达到最大值的（只要足够偏离的话，那肯定是越来越大的）, 我们可以看图，如图1-1所示，当蓝色的线上下移动旋转，绿色只有最小值，没有最大值。那该如何求z呢？一种就是找出a与b的等式替换其中一个。这个不仅麻烦，而且在这里找不到a和b的等式。第二种方式就是通过对z分别求a和b的偏导数，然后使他们等于零得到。0 = 8a + 20b - 56；0 = 20a + 60b - 154；两者联立求出a = 3.5 , b = 1.4，得出最匹配的直线为 y = 3.5 + 1.4x。为什么要等于零。z是一个多元函数，从几何上看，z是一个曲面，由于z恒大于等于零，z类似于如图1-2所示的曲面图。而在数学中，一个多变量的函数的偏导数（英语：partial derivative）是它关于其中一个变量的导数，而保持其他变量恒定。因此两个偏导数要同时等于0才能求出z最小值。 从线性代数角度： 这边就不介绍了，下面是这方面的资料和视频： 最小二乘法的线性代数证明 最小二乘法——百度百科最终我们可以知道最小二乘法公式为： 实验测量值 距离 3 4 5 6 7 8 电压值 2.7 1.8 1.3 1 0.74 0.58 距离 9 10 11 12 13 14 电压值 0.47 0.38 0.33 0.28 0.24 0.2 矩阵形式为： 代码下面的代码就是使用最小二乘法求出从从c,d： % 定义域 r1 r1 = 3:14;a % 区间 v vo1 = [2.7 1.8 1.3 1 0.74 0.58 0.47 0.38 0.33 0.28 0.24 0.2]; % r1的矩阵 A1 = [log10(r1);ones(1,12)]&#39;; % v1的矩阵 v1 = log10(vo1); % v = c*log10(r) + d ,c,d值 ans_cd1 = inv(A1&#39;*A1)*A1&#39;*v1&#39;; fprintf(&#39;ans_cd1 = %g\\n&#39;,ans_cd1);最后用matlab将图形表示出来： x = 3:0.01:14; y = 10.^(-1.70104*log10(x)+1.28584); plot(r1,vo1 ,&#39;green-o&#39;,x,y,&#39;r&#39;); xlabel(&#39;距离&#39;); ylabel(&#39;电压值&#39;); title(&#39;红色线为最小二乘法拟合，绿色线为实际测量值&#39;); grid on图3-1为红外线传感器值与距离的数据拟合图。","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/categories/Matlab/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/tags/Matlab/"}]},{"title":"基于stm32f103任意发送字符串-中级","slug":"基于stm32f103任意发送字符串-中级","date":"2020-04-19T05:36:33.000Z","updated":"2020-05-05T06:23:28.567Z","comments":true,"path":"posts/1076104799/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1076104799/","excerpt":"","text":"实验目的本文主要是实现串口助手发送任意字符串，在屏幕上接收到相同的字符串。 实验环境 软件: stm32cubemx ,keilMDK，Configure Virtual Serial Port Driver，串口助手 硬件：stm32f103开发版 资料：stm32f103中文参考手册 实验现象 实验步骤硬件引脚如图表1-1所示，为stm32f103vet6芯片USART中TX,RX的引脚。本文使用ABP2总线中的USART1串口实现串口接收发送任意字符串。 引脚 ABP2总线 ABP1总线 USART1 USART2 USART3 UART4 UART5 TX PA9 PA2 PB10 PC10 PC12 RX PA10 PA3 PB11 PC11 PD2 软件设计UASRT初始化UASRT初始化就不介绍了，可以在本博客基于stm32cubemx实现串口接收与发送-基础进行学习。 回显任意字符串1.基础接收发送任意字符串中，本文使用的是中断函数。在基础篇中，可以知道，当进入中断函数时，函数调用的是HAL_UART_IRQHandler(&amp;huart1); 这个函数，并且最终在HAL_UART_RxCpltCallback(huart);这个回调函数中进行编写，实现一些功能。由于这些函数都是HAL库中的函数，在接收发送过程中固定的字符个数，无法接收发送任意字符个数。那我们该如何实现接收发送任意个数的字符。首先我们可以看参考手册中数据寄存器(USART_DR)一次接收发送时是什么样的。如图1-2所示：从图中可以看出数据寄存器每次只能接收和发送9位，而一个字符为8位，因此串口每次接收和发送一个字符。那我们该如何实现接收和发送无限制字符串。其实可以这样。每当接收一个字符我们就把这个字符发送出去，这样就可以接收和发送任意字符串。在中断服务函数中，我们可以不用调用HAL_UART_IRQHandler函数，而是直接编写自己的中断函数。下面就是我写的中断函数内容： void USART1_IRQHandler(void) { uint8_t ch; if (__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET)//获取接收中断事件标志 { ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR);//接收字符 WRITE_REG ( huart1.Instance-&gt;DR,ch);//发送字符 } }为什么要这样写，我们可以和51单片机相比较，当51单片机接收一个字符是，RI=1,和__HAL_UART_GET_FLAG( &amp;UartHandle, UART_FLAG_RXNE ) != RESET相当于一个意思。在51单片机中ch=SBUF,表示将接收到的字符放入ch里，类似于我们这ch=( uint16_t)READ_REG(UartHandle.Instance-&gt;DR)这个语句。那么WRITE_REG ( UartHandle.Instance-&gt;DR,ch);也就是发送字符。这里问题来了，为什么在51单片机中，RI要软件清零，而这里不需要。这里我们就需要看芯片的参考手册了。如图1-3所示，在参考手册状态寄存器(USART_SR)中可以找到这个。这里我们可以读到对USART_DR的读操作可以将该位清零。因此可以不需要和51单片机中RI需要软件清零。当然，在初始化中要打开接收中断使能，否在串口中断无法进入。 __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//接收中断使能这样就实现了串口任意接收和发送字符串了。 2. 提升 上面的代码中就是单纯的接收和发送任意字符串。如果我们需要发送一个字符串来控制单片机的某个东西，而且单片机还要发送一串字符，表示已经执行的我们所需要控制的的东西，那我们该怎么办。其实学我们专业都见过这样一个东西，计算机中dos,当我们写入某个指令，按回车就能反馈看的东西。在这里我们也可以用这个方式来实现这个功能。 步骤如下： 接收字符 判断字符是否为’\\n’ 为字符’\\n’flag标志置1，关闭串口中断进行发送字符 flag置0，打开接收中断使能将stm32f1xx_it.c文件中USART1_IRQHandler(void)放入main.c文件下，在中断函数中代码如下： void USART1_IRQHandler(void) { //HAL_UART_IRQHandler(&amp;huart1); uint8_t ch ; if(__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET) { ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR); USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=ch;//接收到的字符保存在 USART_RX_BUF 数组中 if(USART_RX_BUF[USART_RX_STA] == 0X0A &amp;&amp; USART_RX_BUF[USART_RX_STA-1] == 0X0D)//判断是否为&#39;\\n&#39; { flag = 1; //置1 __HAL_UART_DISABLE_IT(&amp;huart1, UART_IT_RXNE);//关闭接收中断 } USART_RX_STA++; //计数接收到的字符的个数 } }USART_RX_BUF数组和USART_RX_STA为全局变量，上面代码中我们将接收到的字符放入USART_RX_BUF数组中，一旦检测到数组中有’\\n’时，flag置1，关闭中断。然后在main.c 里while(1)中加入下面代码： while (1) { /* USER CODE END WHILE */ if(flag) //如果flag为1 { flag = 0;//flag为0 HAL_UART_Transmit(&amp;huart1,USART_RX_BUF,USART_RX_STA,1000);发送字符，查询方式 for(uint16_t i = 0; i&lt;USART_RX_STA; i++) //清空数组 { USART_RX_BUF[i] = 0; } USART_RX_STA = 0; 计数为0 __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//打开接收中断 } /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ }在这段代码中表示当flag=1时，将接收到的字符发送出去，然后清空数组，计数为0最后在打开中断。当然，也可以在里面判断接收的字符串，然后发送自己想看的字符串。 代码的位置代码的位置在main.c文件中，如图1-4,图1-5，图1-6所示：","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"基于stm32cubemx实现串口接收与发送-基础","slug":"基于stm32cubemx实现串口接收与发送","date":"2020-04-12T02:24:54.000Z","updated":"2020-04-15T07:45:36.447Z","comments":true,"path":"posts/34449/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/34449/","excerpt":"","text":"串口是什么 串行接口简称串口，也称 串行通信接口或 串行通讯接口（通常指 COM接口），是采用串行通信方式的扩展接口。串行接口 (Serial Interface) 是指数据一位一位地顺序传送，其特点是 通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。 串口的意义现如今，智能家电，智能手机等一系列智能出现，方便了人们的活动。尤其是串口和蓝牙连接，可与实现无线数据之间的信息交流。这样就可以实现一台设备控制另一台设备。方便人们的生活。 串口的实现在实现无线数据之间的信息交流时，首先应该先实现串口功能。 资料和软件 软件：Stm32CubeMx ,keilMDK 芯片：stm32f103RE 资料：STM32F10x参考手册 STM32中USART介绍 STM32芯片具有多个 USART 外设用于串口通讯，它是 Universal SynchronousAsynchronous Receiver and Transmitter的缩写，即通用同步异步收发器可以灵活地与外部设备进行全双工数据交换。有别于 USART，它还有具有 UART 外设(Universal AsynchronousReceiver and Transmitter)，它是在 USART基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。 USART初始化在学习Stm32CubeMx，HAL库版本时，首先应该了解Stm32寄存器版本。简单来说，HAL库其实就是对Stm32寄存器的封装。下方链接是对串口知识的讲解： 串口通信基本原理 【STM32】串口相关配置寄存器、库函数（UART一般步骤） 在寄存器版本中实现串口功能，有以及几个步骤： RX和TX引脚GPIO时钟和USART时钟； 初始化GPIO口，并将GPIO复用到USART上； 配置USART参数； 配置中断并使能USART中断； 使能USART; 在USART中断服务函数实现数据接收和发送。 在寄存器版本中，需要将这些步骤逐一的写代码，然而在Stm32CubeMx中，只需要进行图形界面配置就可以完成1~5的步骤。下面的视频就是Stm32CubeMx对串口的配置，在配置过程中时钟都是默认配置。 keilMDK中代码的介绍 打开生成的代码可以看到，在main.c文件中可以找到串口初始化的代码： static void MX_USART1_UART_Init(void) { /* USER CODE BEGIN USART1_Init 0 */ /* USER CODE END USART1_Init 0 */ /* USER CODE BEGIN USART1_Init 1 */ /* USER CODE END USART1_Init 1 */ huart1.Instance = USART1; //USART1 huart1.Init.BaudRate = 9600; //波特率9600 huart1.Init.WordLength = UART_WORDLENGTH_8B; //字长为8位格式 huart1.Init.StopBits = UART_STOPBITS_1; //一个停止位 huart1.Init.Parity = UART_PARITY_NONE; //无奇偶校验位 huart1.Init.Mode = UART_MODE_TX_RX; //接收和发送模式 huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; //无硬件流控 huart1.Init.OverSampling = UART_OVERSAMPLING_16; //可配置的16倍过采样或8倍过采样 if (HAL_UART_Init(&amp;huart1) != HAL_OK) { Error_Handler(); } /* USER CODE BEGIN USART1_Init 2 */ /* USER CODE END USART1_Init 2 */ }从void MX_USART1_UART_Init(void)函数中可以看出，使用USART1串口的异步通信，串口波特率为9600，字长为8bit,1个停止位，无奇偶校验位，无硬件流控。 在 stm32f1xx_hal_msp.c 中，生成了串口 MSP 函数 HAL_UART_MspInit，这里可以看到是对时钟，GPIO,NVIC的配置，内容如下： void HAL_UART_MspInit(UART_HandleTypeDef* huart) { GPIO_InitTypeDef GPIO_InitStruct = {0}; if(huart-&gt;Instance==USART1) { /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); //使能USART1时钟 __HAL_RCC_GPIOA_CLK_ENABLE(); //使能GPIOA时钟 /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9; //选择Px.9引脚 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; //复用推挽模式 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; //高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); //初始化PA9 GPIO_InitStruct.Pin = GPIO_PIN_10; //选择Px.10引脚 GPIO_InitStruct.Mode = GPIO_MODE_INPUT; //输入模式 GPIO_InitStruct.Pull = GPIO_NOPULL; //无上下拉 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); //初始化PA10 /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 1, 1); //优先级1，子优先级1 HAL_NVIC_EnableIRQ(USART1_IRQn); //使能USART1中断通道 /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ } } 在stm32f1xx_it.c文件中可以找到，USART1的中断函数void USART1_IRQHandler(void)，内容如下： void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(&amp;huart1); //调用 HAL 库中断处理公用函数 /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */ }在寄存器版本中，void USART1_IRQHandler(void)是对串口中断处理的。将所处理的事件写入这个函数中。然而在这里，可以看到 HAL_UART_IRQHandler(&amp;huart1);的这个函数。在这里无法看到函数的意义，可以鼠标左击，然后按F12键进入这个函数,下面是HAL_UART_IRQHandler(&amp;huart1)这个函数的一些省略。 void HAL_UART_IRQHandler(UART_HandleTypeDef *huart) { ...... /* If no error occurs */ errorflags = (isrflags &amp; (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE)); if (errorflags == RESET) { /* UART in mode Receiver */ if (((isrflags &amp; USART_SR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) { UART_Receive_IT(huart); return; } } /* If some errors occur */ if ((errorflags != RESET) &amp;&amp; (((cr3its &amp; USART_CR3_EIE) != RESET) || ((cr1its &amp; (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))...... ....... /* UART in mode Transmitter*/ if (((isrflags &amp; USART_SR_TXE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TXEIE) != RESET)) { UART_Transmit_IT(huart); return; } ...... }从这里可以看到两种情况，一种是判断是否错误的占用，另一种判断中断是接收还是发送。本文使用的是接收中断，这时我们可以进入UART_Receive_IT(huart)这个函数里查看函数内容。 static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart) { uint16_t *tmp; /* Check that a Rx process is ongoing */ if (huart-&gt;RxState == HAL_UART_STATE_BUSY_RX) //检查接收是否在进行中 { if (huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) //判断字长为9位 { tmp = (uint16_t *) huart-&gt;pRxBuffPtr; if (huart-&gt;Init.Parity == UART_PARITY_NONE) { *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x01FF); huart-&gt;pRxBuffPtr += 2U; } else { *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x00FF); huart-&gt;pRxBuffPtr += 1U; } } else //字长为8位 { if (huart-&gt;Init.Parity == UART_PARITY_NONE) //判断奇偶校验位（无奇偶校验位） { //接收到的数据放入缓存指针pRxBuffPtr中，每次接收一个字符 *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x00FF); } else { *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x007F); } } if (--huart-&gt;RxXferCount == 0U)//判断计数器RxXferCount是否为0，每接收一个字符，RxXferCount减1 { /* Disable the UART Data Register not empty Interrupt */ __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE); //关闭接收中断 /* Disable the UART Parity Error Interrupt */ __HAL_UART_DISABLE_IT(huart, UART_IT_PE); //关闭校验错误中断 /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */ __HAL_UART_DISABLE_IT(huart, UART_IT_ERR); //关闭一些错误中断 /* Rx process is completed, restore huart-&gt;RxState to Ready */ huart-&gt;RxState = HAL_UART_STATE_READY; //恢复huart #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) //判断是否进入UART回调函数 /*Call registered Rx complete callback*/ huart-&gt;RxCpltCallback(huart); #else /*Call legacy weak Rx complete callback*/ HAL_UART_RxCpltCallback(huart); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ return HAL_OK; } return HAL_OK; } else { return HAL_BUSY; } }这里可以看到，当数据接收完成，使用函数HAL_UART_RxCpltCallback(huart)。当进入这个函数时可以看到__weak,表示如果自己定义了同名的函数就不用他，如果你没定义就使用这个弱函数。到了这里才将这个工程文件理解。接下来就来写代码实现串口的接收与发送。 实现串口接收与发送在实现串口接收与发送，需要使用两个函数： HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 串口中断模式发送 HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);串口中断模式接收 进入函数HAL_UART_Receive_IT();代码如下： HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { /* Check that a Rx process is not already ongoing */ if (huart-&gt;RxState == HAL_UART_STATE_READY) //判断是否准备就绪 { if ((pData == NULL) || (Size == 0U)) { return HAL_ERROR; } /* Process Locked */ __HAL_LOCK(huart); 锁住huart huart-&gt;pRxBuffPtr = pData; //将所要接收的字符放入缓存指针pRxBuffPtr中 huart-&gt;RxXferSize = Size; //将Size赋值给RxXferSize huart-&gt;RxXferCount = Size; //将Size赋值给RxXferCount,用来数据计数 huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; //检查是否为空 huart-&gt;RxState = HAL_UART_STATE_BUSY_RX; //忙于接收 /* Process Unlocked */ __HAL_UNLOCK(huart); 打开huart /* Enable the UART Parity Error Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_PE); //打开校验错误中断 /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */ __HAL_UART_ENABLE_IT(huart, UART_IT_ERR); //打开错误中断 /* Enable the UART Data Register not empty Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE); //打开接收中断 return HAL_OK; } else { return HAL_BUSY; } }这里可以看出该函数会开启接收中断并且设置接收缓冲以及接收缓冲接收最大数据量。函数HAL_UART_Transmit_IT();与HAL_UART_Receive_IT()相似;因此不一一介绍了。接下来将这些代码加入main.c文件中（图3-1~3）进行编译： uint8_t aRxBuffer; HAL_UART_Receive_IT(&amp;huart1,&amp;aRxBuffer,1); void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { UNUSED(huart); HAL_UART_Transmit_IT(&amp;huart1,&amp;aRxBuffer,1);//开启接收中断，缓存区，接收的字符量为1 } 实现KeilMDK串口仿真KeilMDK的仿真类似于本博客中的51单片机发送与接收；但是要注意以下两点： 在debug框中将两个数据改掉，如图4-1所示： 在Command框下写成如图4-2所示的指令：完成之后就完成了软件仿真（图4-3）。","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"verilog-HDL仿真","slug":"verilog-HDL仿真","date":"2020-04-02T09:53:10.000Z","updated":"2020-04-12T09:19:50.716Z","comments":true,"path":"posts/8279/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/8279/","excerpt":"关于modelsim仿真","text":"关于modelsim仿真 modelsim是单内核支持VHDL和Verilog HDL混合仿真的仿真器，是做FPGA/ASIC设计的RTL级和门级电路仿真的好选择。modelsim仿真 本身就是编写testbench的过程。通过Testbench模块向待测模块输出信号作为激励，同时接收从待测模块输出的信号来查看结果。本文 介绍如何实现Verilog HDL仿真。 步骤 打开modelsim软件，选择File-&gt;new-&gt;Library…,出现如图1-1所示的界面创建库,选择 a new library and a logical mapping to it , 在Library Name 下写work，点击ok。 接下来选择 File-&gt;new-&gt;Project… , 出现如图1-2所示的界面创建工程环境。依次为工程文件名，文件存放位置，所在的库。 在空白处右击，选择Add To Project-&gt;Existing File… ,出现如图1-3所示的界面，点击Browse…，选择所仿真的文件,这里我选择的文件c.v代码在下面。 点击new file ，在软件右侧出现文本框，输入以下代码进行保存，文件名与module后的名字一样如下面代码tb2.v。 `timescale 1ns/1ns `include\"./c.v\" module tb2; reg clk; wire L1,L2; initial begin clk=0; end always #10 clk=~clk; c i1(.clk(clk),.L1(L1),.L2(L2)); endmodule `timescale 1ns/1ns 是用来时间轴设置的，这里表示仿真的时间轴单位是1ns，仿真工具仿真的最大精度只到1ns内的逻辑变化。待测模块中的reg型信号在Testbench中就变成了wire，待测模块中的wire型信号在Testbench中则对应为reg型。initial 表示初始化。always #10 clk=~clk;是用来时钟产生的，这里表示每10ns（与时间轴设置有关），clk来一次高低电平转换。c i1(.clk(clk),.L1(L1),.L2(L2));c是我们想要仿真的模块，il是我们创建的对象名，类似于java中的类与对象关系。 完成保存后，按照3的步骤将tb2.v添加进来。然后鼠标右击，选择Compile-&gt;Compile All,界面出现如图1-4 所示，如果左下角出现红色字体，说明模块编译错误。 点击左下角Library，选择work-&gt;tb2,右击Simulate,如果work为空，重启该软件。完成后，选择左侧的il，右击选择Add All。出现图1-5所示的界面。 最后选择Simulate-&gt;Run-&gt;Run-All,然后点击Wave -default下的变量，出现下图1-6运行的仿真。 代码 c.v module c(L1,L2,clk); output L1,L2; input clk; reg L1,L2; reg[1:0] counter1; reg[3:0] counter2; initial begin L1=1'b1; L2=1'b1; counter1=0; counter2=0; end always@(posedge clk) begin counter1=counter1+1; if(counter1==2'd3) begin L1=~L1; counter1=0; end end always@(posedge clk) begin counter2=counter2+1; if(counter2==4'd12) begin L2=~L2; counter2=0; end end endmodule","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"51单片机发送与接收","slug":"51单片机-串口","date":"2020-03-28T09:29:03.000Z","updated":"2020-04-09T10:52:04.332Z","comments":true,"path":"posts/17792/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/17792/","excerpt":"串口","text":"串口 串口的发送与接收简单理解一下，51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。 串口有以下几个寄存器 串行端口缓冲寄存器（SBUF）： 地址是99H。有两个缓冲器，一个是只写发送寄存器，一个是只读接收寄存器。 串行端口控制寄存器（SCON）：地址是98H，可以位寻址。如表1-1所示： 表1-1SCON简表 位 符号 地址 模式 SCON.7 SM0 9FH 串行端口模式位0 SCON.6 SM1 9EH 串行端口模式位1 SCON.5 SM2 9DH 串行端口模式位2 SCON.4 REN 9CH 置1为允许接收 SCON.3 TB8 9BH 发送数据的位8 SCON.2 RB0 9AH 接收数据的位8 SCON.1 TI 99H 发送中断标志，字符数据发送完毕时硬件置位，由软件清零 SCON.0 RI 98H 接收中断标志，字符数据发送完毕时硬件置位，由软件清零 表1-2串行端口工作模式 SM0 SM1 模式 描述 波特率 0 0 0 移位寄存器 固定 0 1 1 8位UART 可变（由定时器T1控制） 1 0 2 9位UART 固定 1 1 3 9位UART 可变 这里我用的是模式1实现串口通信。 keilC51 工程 这里，我以接收字符’A’,’B’控制发送字符，使用串口中断试下字符接收与发送。代码如下： #include &lt;reg51.h> unsigned char receiveDate; void UART_Init() { SCON = 0x50; TMOD = 0x20; PCON=PCON&amp;0x7f; TH1 = -3; TL1 = -3; TR1 = 1; ES = 1; //串口中断允许位 } void put1(char c) { SBUF = c; while(!TI); TI = 0; } void ISR_Init() { EA = 1; } void putall(char *s) //指针所指向的地址的值 { while(*s) { put1(*s); //字符发送函数 s++; //地址指向下一个 } } void uart_0() interrupt 4 { if(RI) { receiveDate = SBUF; //接收字符 RI = 0; } } void main() { UART_Init(); //串口初始化 ISR_Init(); //总中断初始化 while(1) { if(receiveDate == 'A') //接收字符为'A',发送字符串“abcdef \\n” putall(\"abcdef \\n\"); else if(receiveDate == 'B')//接收字符为'B',发送字符串“psw\\n” putall(\"psw\\n\"); } } 我们使用虚拟串口驱动，实现端口的映射，如图2-1所示，点击添加端口，实现COM3-&gt;COM4映射（图左侧已实现） 如图2-2，所示：在kileC51中右击Target-&gt; Options for Target ‘Target 1’-&gt;Debug,将 Use Simulator，Limit Speed to Real-Time 选中（作用是选择Options for Target ‘Target 1’中Target里Xtal的晶振）。图2-2 如图2-3所示，点击 Start/Stop Debug Session,在keilC51左下角输入MODE COM3 9600,0,8,1 以及ASSIGN COM3 SOUT 指令,成功后虚拟串口驱动左侧COM3会出现[9600-N-8-1] 在串口助手这里选择COM4端口。这样就实现了串口软件虚拟仿真。","categories":[],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"android studio/app的工程结构","slug":"android-studio","date":"2020-03-27T10:42:50.000Z","updated":"2020-04-23T09:24:48.654Z","comments":true,"path":"posts/61305/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/61305/","excerpt":"App的工程结构","text":"App的工程结构 1.工程目录说明如图1-1所示，该工程有两个目录：一个是app,另一个是Gradle Scripts。 app下面有3个子目录，功能说明如下： (1)manifests目录，下面只有一个xml文件，AndroidManifest.xml,是App的运行配置文件。 (2)java目录，有3个包，第一个包存放的是App工程的java源代码，后面两个包存放的是测试用的Java代码。 (3)res目录，存放的是App工程的资源文件。 drawable 图形描述文件与用户图片存放位置。 layout App页面的布局文件存放位置。 mipmap 是启动图标存放位置。 values 是一些常量定义文件存放位置，比如字符串 string.xml,像素 dimens.xml,颜色 colors.xml等。 图1-1 工程目录结构图 Gradle Scripts主要是工程的编译配置文件 build.gradle，该文件分为项目级和模块级两种，用于描述App工程的编译规则。 proguard-rules.pro，该文件用于描述java文件的代码混淆规则。 gradle.properties，该文件用于配置编译工程的命令行参数，一般无需改动。 settings.gradle，配置哪些模块在一起编译。初始为include’:app’,表示只编译App模块。 local.properties，项目的本地配置，一般无需改动。用于描述开发者本机的环境配置。 2.编译配置文件build.gradleapply plugin: &#39;com.android.application&#39; android { //指定编译用的SDK版本号。如29表示使用Android 10.0编译 compileSdkVersion 29 //指定编译工具的版本号，这里的头两位数字必须与compileSdkVersion保持一致 //，具体的版本号可在sdk安装目录的“sdk/build-tools”下找到 buildToolsVersion &quot;29.0.3&quot; defaultConfig { //指定该模块的应用编号，App的包名。该参数自动生成，无需修改 applicationId &quot;com.example.day02&quot; //指定App适合运行的最小SDk版本号，如28表示至少要在Android 9.0上运行 minSdkVersion 28 //指定目标设备的SDK版本号，即该App最希望在哪个版本的Android上运行 targetSdkVersion 29 //指定App的应用版本号 versionCode 1 //指定App的应用版本名称 versionName &quot;1.0&quot; //一个Instrumentation运行针对Android包（应用程序）JUnit3和JUnit4测试。 //AndroidJUnitRunner 类是一个 JUnit 测试运行程序，可让您在 Android 设备上运行 //JUnit3或JUnit4型测试类，包括使用 Espresso 和 UI Automator 测试框架的测试类。 testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { //指定是否开启代码混淆功能。true 表示开启混淆，false表示无需混淆 minifyEnabled false //指定代码混淆规则文件的文件名 proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39; } } } //用于指明需要用到的第三方库，通常AS 项目中一共有三种依赖方式：本地依赖、库依赖和远程依赖。 dependencies { //指定引用jar包的路径 implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) //依赖的基础库 implementation &#39;androidx.appcompat:appcompat:1.1.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39; //指定单元测试编译用的junit版本号 testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39; }3.App运行配置AndroidManifest.xml AndroidManifest.xml用于指定App内部的运行配置，是一个XML描述文件。 application 用于指定App的自身属性 activity 元素该元素声明一个实现应用可视化界面的Activity（Activity类子类）。这是 application 元素中必要的子元素。所有Activity都必须由清单文件中的 activity 元素表示。任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。 intent-filter 元素,指明这个activity可以以什么样的意图(intent)启动。该元素有几个子元素可以包含。我们先介绍遇到的这两个： action 元素,表示activity作为一个什么动作启动,android.intent.action.MAIN表示作为主activity启动。 category 元素,这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。 android:name 数据项名称。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.day02&quot;&gt; &lt;application //用于指定是否允许备份，开发阶段设置为true,上线时设置为false android:allowBackup=&quot;true&quot; //用于指定该App在手机屏幕上显示的图标 android:icon=&quot;@mipmap/ic_launcher&quot; //用于指定该App在手机屏幕上显示的名称 android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; //true表示支持阿拉伯语/波斯语这种从右往左的文字排列顺序 android:supportsRtl=&quot;true&quot; //指定该App的显示风格 android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 4.在代码中操控控件创建工程时，Android Studio 默认打开两个文件，布局文件 activity_main.xml和代码文件MainActivity.java进行第一次工程编写。 activity_main.xml &lt;TextView android:id=&quot;@+id/psw&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt; MainActivity.java public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //当前的页面布局采用的是res/layout/activity_main setContentView(R.layout.activity_main); //获取名叫psw的TextView控件 TextView psw = findViewById(R.id.psw); //设置TextView控件的文字内容 psw.setText(&quot;我的第一个工程文件&quot;); //设置TextView控件的文字颜色 psw.setTextColor(Color.RED); //设置TextView控件的文字的大小 psw.setTextSize(30); } }保存文件后依次选择菜单Run-&gt;Run’app’,模拟器上运行的结果如图4-1所示。 图4-1 模拟器界面","categories":[{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/categories/ANDROID-STUDIO/"}],"tags":[{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]},{"title":"myfirst","slug":"myfirst","date":"2020-03-24T01:53:57.000Z","updated":"2020-04-12T09:20:16.982Z","comments":true,"path":"posts/63271/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/63271/","excerpt":"我的博客文章编写","text":"我的博客文章编写 标题使用标题时需要#号 段落这是第一个段落内容 这是第二个段落内容 区块引用 h 这是一段引用段落，将会被高亮显示 超链接百度 图片 无序列表 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 有序列表 分割线","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"},{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/categories/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/categories/Matlab/"},{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/categories/ANDROID-STUDIO/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"},{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/tags/Matlab/"},{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]}