{"meta":{"title":"平湖烟雨","subtitle":"爆炒三文鱼","description":"","author":"潘苏皖","url":"https://pan_su_wan.gitee.io","root":"/"},"pages":[{"title":"tags","date":"2020-04-07T09:42:26.000Z","updated":"2020-04-07T09:43:14.944Z","comments":true,"path":"tags/index.html","permalink":"https://pan_su_wan.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-07T09:40:13.000Z","updated":"2020-04-07T09:41:48.359Z","comments":true,"path":"categories/index.html","permalink":"https://pan_su_wan.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"verilog-HDL仿真","slug":"verilog-HDL仿真","date":"2020-04-02T09:53:10.000Z","updated":"2020-04-09T10:03:33.920Z","comments":true,"path":"2020/04/02/verilog-HDL仿真/","link":"","permalink":"https://pan_su_wan.gitee.io/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/","excerpt":"关于modelsim仿真","text":"关于modelsim仿真 modelsim是单内核支持VHDL和Verilog HDL混合仿真的仿真器，是做FPGA/ASIC设计的RTL级和门级电路仿真的好选择。modelsim仿真 本身就是编写testbench的过程。通过Testbench模块向待测模块输出信号作为激励，同时接收从待测模块输出的信号来查看结果。本文 介绍如何实现Verilog HDL仿真。 步骤 打开modelsim软件，选择File-&gt;new-&gt;Library…,出现如图1-1所示的界面创建库,选择 a new library and a logical mapping to it , 在Library Name 下写work，点击ok。 接下来选择 File-&gt;new-&gt;Project… , 出现如图1-2所示的界面创建工程环境。依次为工程文件名，文件存放位置，所在的库。 在空白处右击，选择Add To Project-&gt;Existing File… ,出现如图1-3所示的界面，点击Browse…，选择所仿真的文件,这里我选择的文件c.v代码在下面。 点击new file ，在软件右侧出现文本框，输入以下代码进行保存，文件名与module后的名字一样如下面代码tb2.v。 `timescale 1ns/1ns `include\"./c.v\" module tb2; reg clk; wire L1,L2; initial begin clk=0; end always #10 clk=~clk; c i1(.clk(clk),.L1(L1),.L2(L2)); endmodule `timescale 1ns/1ns 是用来时间轴设置的，这里表示仿真的时间轴单位是1ns，仿真工具仿真的最大精度只到1ns内的逻辑变化。待测模块中的reg型信号在Testbench中就变成了wire，待测模块中的wire型信号在Testbench中则对应为reg型。initial 表示初始化。always #10 clk=~clk;是用来时钟产生的，这里表示每10ns（与时间轴设置有关），clk来一次高低电平转换。c i1(.clk(clk),.L1(L1),.L2(L2));c是我们想要仿真的模块，il是我们创建的对象名，类似于java中的类与对象关系。 完成保存后，按照3的步骤将tb2.v添加进来。然后鼠标右击，选择Compile-&gt;Compile All,界面出现如图1-4 所示，如果左下角出现红色字体，说明模块编译错误。 点击左下角Library，选择work-&gt;tb2,右击Simulate,如果work为空，重启该软件。完成后，选择左侧的il，右击选择Add All。出现图1-5所示的界面。 最后选择Simulate-&gt;Run-&gt;Run-All,然后点击Wave -default下的变量，出现下图1-6运行的仿真。 代码 c.v module c(L1,L2,clk); output L1,L2; input clk; reg L1,L2; reg[1:0] counter1; reg[3:0] counter2; initial begin L1=1'b1; L2=1'b1; counter1=0; counter2=0; end always@(posedge clk) begin counter1=counter1+1; if(counter1==2'd3) begin L1=~L1; counter1=0; end end always@(posedge clk) begin counter2=counter2+1; if(counter2==4'd12) begin L2=~L2; counter2=0; end end endmodule","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"51单片机发送与接收","slug":"51单片机-串口","date":"2020-03-28T09:29:03.000Z","updated":"2020-04-09T10:52:04.332Z","comments":true,"path":"2020/03/28/51单片机-串口/","link":"","permalink":"https://pan_su_wan.gitee.io/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/","excerpt":"串口","text":"串口 串口的发送与接收简单理解一下，51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。 串口有以下几个寄存器 串行端口缓冲寄存器（SBUF）： 地址是99H。有两个缓冲器，一个是只写发送寄存器，一个是只读接收寄存器。 串行端口控制寄存器（SCON）：地址是98H，可以位寻址。如表1-1所示： 表1-1SCON简表 位 符号 地址 模式 SCON.7 SM0 9FH 串行端口模式位0 SCON.6 SM1 9EH 串行端口模式位1 SCON.5 SM2 9DH 串行端口模式位2 SCON.4 REN 9CH 置1为允许接收 SCON.3 TB8 9BH 发送数据的位8 SCON.2 RB0 9AH 接收数据的位8 SCON.1 TI 99H 发送中断标志，字符数据发送完毕时硬件置位，由软件清零 SCON.0 RI 98H 接收中断标志，字符数据发送完毕时硬件置位，由软件清零 表1-2串行端口工作模式 SM0 SM1 模式 描述 波特率 0 0 0 移位寄存器 固定 0 1 1 8位UART 可变（由定时器T1控制） 1 0 2 9位UART 固定 1 1 3 9位UART 可变 这里我用的是模式1实现串口通信。 keilC51 工程 这里，我以接收字符’A’,’B’控制发送字符，使用串口中断试下字符接收与发送。代码如下： #include &lt;reg51.h> unsigned char receiveDate; void UART_Init() { SCON = 0x50; TMOD = 0x20; PCON=PCON&amp;0x7f; TH1 = -3; TL1 = -3; TR1 = 1; ES = 1; //串口中断允许位 } void put1(char c) { SBUF = c; while(!TI); TI = 0; } void ISR_Init() { EA = 1; } void putall(char *s) //指针所指向的地址的值 { while(*s) { put1(*s); //字符发送函数 s++; //地址指向下一个 } } void uart_0() interrupt 4 { if(RI) { receiveDate = SBUF; //接收字符 RI = 0; } } void main() { UART_Init(); //串口初始化 ISR_Init(); //总中断初始化 while(1) { if(receiveDate == 'A') //接收字符为'A',发送字符串“abcdef \\n” putall(\"abcdef \\n\"); else if(receiveDate == 'B')//接收字符为'B',发送字符串“psw\\n” putall(\"psw\\n\"); } } 我们使用虚拟串口驱动，实现端口的映射，如图2-1所示，点击添加端口，实现COM3-&gt;COM4映射（图左侧已实现） 如图2-2，所示：在kileC51中右击Target-&gt; Options for Target ‘Target 1’-&gt;Debug,将 Use Simulator，Limit Speed to Real-Time 选中（作用是选择Options for Target ‘Target 1’中Target里Xtal的晶振）。图2-2 如图2-3所示，点击 Start/Stop Debug Session,在keilC51左下角输入MODE COM3 9600,0,8,1 以及ASSIGN COM3 SOUT 指令,成功后虚拟串口驱动左侧COM3会出现[9600-N-8-1] 在串口助手这里选择COM4端口。这样就实现了串口软件虚拟仿真。","categories":[],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"android studio/app的工程结构","slug":"android-studio","date":"2020-03-27T10:42:50.000Z","updated":"2020-04-09T10:03:33.918Z","comments":true,"path":"2020/03/27/android-studio/","link":"","permalink":"https://pan_su_wan.gitee.io/2020/03/27/android-studio/","excerpt":"App的工程结构","text":"App的工程结构 1.工程目录说明如图1-1所示，该工程有两个目录：一个是app,另一个是Gradle Scripts。 app下面有3个子目录，功能说明如下： (1)manifests目录，下面只有一个xml文件，AndroidManifest.xml,是App的运行配置文件。 (2)java目录，有3个包，第一个包存放的是App工程的java源代码，后面两个包存放的是测试用的Java代码。 (3)res目录，存放的是App工程的资源文件。 drawable 图形描述文件与用户图片存放位置。 layout App页面的布局文件存放位置。 mipmap 是启动图标存放位置。 values 是一些常量定义文件存放位置，比如字符串 string.xml,像素 dimens.xml,颜色 colors.xml等。 图1-1 工程目录结构图 Gradle Scripts主要是工程的编译配置文件 build.gradle，该文件分为项目级和模块级两种，用于描述App工程的编译规则。 proguard-rules.pro，该文件用于描述java文件的代码混淆规则。 gradle.properties，该文件用于配置编译工程的命令行参数，一般无需改动。 settings.gradle，配置哪些模块在一起编译。初始为include’:app’,表示只编译App模块。 local.properties，项目的本地配置，一般无需改动。用于描述开发者本机的环境配置。2.编译配置文件build.gradleapply plugin: 'com.android.application' android { //指定编译用的SDK版本号。如29表示使用Android 10.0编译 compileSdkVersion 29 //指定编译工具的版本号，这里的头两位数字必须与compileSdkVersion保持一致 //，具体的版本号可在sdk安装目录的“sdk/build-tools”下找到 buildToolsVersion “29.0.3” defaultConfig { //指定该模块的应用编号，App的包名。该参数自动生成，无需修改 applicationId &quot;com.example.day02&quot; //指定App适合运行的最小SDk版本号，如28表示至少要在Android 9.0上运行 minSdkVersion 28 //指定目标设备的SDK版本号，即该App最希望在哪个版本的Android上运行 targetSdkVersion 29 //指定App的应用版本号 versionCode 1 //指定App的应用版本名称 versionName &quot;1.0&quot; //一个Instrumentation运行针对Android包（应用程序）JUnit3和JUnit4测试。 //AndroidJUnitRunner 类是一个 JUnit 测试运行程序，可让您在 Android 设备上运行 //JUnit3或JUnit4型测试类，包括使用 Espresso 和 UI Automator 测试框架的测试类。 testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { //指定是否开启代码混淆功能。true 表示开启混淆，false表示无需混淆 minifyEnabled false //指定代码混淆规则文件的文件名 proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39; } }} //用于指明需要用到的第三方库，通常AS 项目中一共有三种依赖方式：本地依赖、库依赖和远程依赖。dependencies { //指定引用jar包的路径 implementation fileTree(dir: ‘libs’, include: [‘*.jar’]) //依赖的基础库 implementation ‘androidx.appcompat:appcompat:1.1.0’ implementation ‘androidx.constraintlayout:constraintlayout:1.1.3’ //指定单元测试编译用的junit版本号 testImplementation ‘junit:junit:4.12’ androidTestImplementation ‘androidx.test.ext:junit:1.1.1’ androidTestImplementation ‘androidx.test.espresso:espresso-core:3.2.0’} ## 3.App运行配置AndroidManifest.xml AndroidManifest.xml用于指定App内部的运行配置，是一个XML描述文件。 * &lt;application&gt;用于指定App的自身属性 * &lt;activity&gt;元素该元素声明一个实现应用可视化界面的Activity（Activity类子类）。 这是&lt;application&gt;元素中必要的子元素。所有Activity都必须由清单文件中的&lt;activity&gt;元素表示。 任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。 * &lt;intent-filter&gt;元素,指明这个activity可以以什么样的意图(intent)启动。 该元素有几个子元素可以包含。我们先介绍遇到的这两个： * &lt;action&gt;元素,表示activity作为一个什么动作启动, android.intent.action.MAIN表示作为主activity启动。 * &lt;category&gt;元素,这是action元素的额外类别信息， android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。 * android:name 数据项名称。 ``` bash &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.day02&quot;&gt; &lt;application //用于指定是否允许备份，开发阶段设置为true,上线时设置为false android:allowBackup=&quot;true&quot; //用于指定该App在手机屏幕上显示的图标 android:icon=&quot;@mipmap/ic_launcher&quot; //用于指定该App在手机屏幕上显示的名称 android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; //true表示支持阿拉伯语/波斯语这种从右往左的文字排列顺序 android:supportsRtl=&quot;true&quot; //指定该App的显示风格 android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;4.在代码中操控控件 创建工程时，Android Studio 默认打开两个文件，布局文件 activity_main.xml和代码文件MainActivity.java 进行第一次工程编写。 activity_main.xml &lt;TextView android:id=\"@+id/psw\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" tools:ignore=\"MissingConstraints\" /> MainActivity.java public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //当前的页面布局采用的是res/layout/activity_main setContentView(R.layout.activity_main); //获取名叫psw的TextView控件 TextView psw = findViewById(R.id.psw); //设置TextView控件的文字内容 psw.setText(\"我的第一个工程文件\"); //设置TextView控件的文字颜色 psw.setTextColor(Color.RED); //设置TextView控件的文字的大小 psw.setTextSize(30); } } 保存文件后依次选择菜单Run-&gt;Run’app’,模拟器上运行的结果如图4-1所示。 图4-1 模拟器界面","categories":[],"tags":[{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]},{"title":"myfirst","slug":"myfirst","date":"2020-03-24T01:53:57.000Z","updated":"2020-04-09T10:03:33.919Z","comments":true,"path":"2020/03/24/myfirst/","link":"","permalink":"https://pan_su_wan.gitee.io/2020/03/24/myfirst/","excerpt":"我的博客文章编写","text":"我的博客文章编写 标题使用标题时需要#号 段落这是第一个段落内容 这是第二个段落内容 区块引用 h 这是一段引用段落，将会被高亮显示 超链接百度 图片 无序列表 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 有序列表 分割线","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-02T09:53:10.000Z","updated":"2020-04-09T10:03:33.920Z","comments":true,"path":"2020/03/02/hello-world/","link":"","permalink":"https://pan_su_wan.gitee.io/2020/03/02/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]}