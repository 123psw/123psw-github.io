{"meta":{"title":"平湖烟雨","subtitle":"爆炒三文鱼","description":"","author":"潘苏皖","url":"https://pan_su_wan.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-07T09:40:13.000Z","updated":"2020-04-07T09:41:48.359Z","comments":true,"path":"categories/index.html","permalink":"https://pan_su_wan.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-07T09:42:26.000Z","updated":"2020-04-07T09:43:14.944Z","comments":true,"path":"tags/index.html","permalink":"https://pan_su_wan.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于智能小车电机的选取","slug":"关于智能小车电机的选取","date":"2020-05-31T04:52:47.000Z","updated":"2020-05-31T04:52:47.131Z","comments":true,"path":"posts/906927798/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/906927798/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"红外传感器距离与电压对数函数的由来","slug":"关于红外传感器输出电压和迷宫墙距离函数关系研究","date":"2020-05-31T02:03:51.000Z","updated":"2020-05-31T04:57:26.195Z","comments":true,"path":"posts/2339799628/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/2339799628/","excerpt":"","text":"材料 stm32F401RET6小刚炮 OSE-1L7，2SC3325资料 OSE-1L7数据手册 2SC3325数据手册 TSL262R数据手册红外线发射接收端电路如图1-1所示，为红外线发射接收端电路。VB为stm32F401RET6的引脚控制端。PS为8.4V的电压。由于stm32F401RET6的引脚输出电压为3.3V,而VBE的压降约为0.8V所以Ib的计算方式为：从OSE-1L1数据手册中可以找到额定电压为1.35V，额定电流为100mA,所以Vce电压为：Vce = 8.4V-(5x1.35V) = 1.65V如图1-2所示，当Ib=0.5mA,Vce=1.65V时，IC电流约为90mA,符合OSE-1L1的额定电流。 OSE-1L7分析从数据手册中可以看到，发出红外线波长集中在940nm(图2-1)，而且在顺向电流50mA时，发射光强度为50mW/sr，同时超过10度以外，发射光的强度相对正前方下降至一半以下(图2-2)。从图2-3可以看出超过50mW/sr的用虚线表示，但前面估算出90mA的顺向电流，因此可以估测会有以下的发射量：球面度球面度是一个立体角的计量单位。面积为半径平方(r2)的球表面对球心的张角等于1球面度。因此可以将发射强度为90mW/sr换算为(90/r2)mW/cm2=(90000/r2)uW/cm2。 TSL262R分析TSL262R为红外线接收端，从数据手册中看出可以接收940nm的红外线波长。如图4-1所示，光感测器TSL262R输出电压与接收光能量强度图形，可以写出下列函数公式：我们OSE-1L7分析中将(90000/r2)uW/cm2值代入这个函数中可以算出在某一距离下TSL262R输出电压值：但是由于不同的电路，发射强度不一定时90mW/sr,而且还要一些其他因素。假设输出电压与接收光能量强度的线性关系不会因为这些情况影响。那么我们可以写成下面的公式：也可以改写为：其中Z代表着OSE-1L7发射强度以及一些其他影响，r表式距离。那么最终可以写成距离和电压的对数数学公式：","categories":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/categories/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}],"tags":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"}]},{"title":"fritzing软件的使用","slug":"fritzing软件的使用","date":"2020-05-04T11:23:33.000Z","updated":"2020-05-05T06:22:12.197Z","comments":true,"path":"posts/3908916139/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/3908916139/","excerpt":"","text":"fritzing是什么 Fritzing是一项开放源代码的硬件计划，该计划使电子产品可以作为任何人的创意材料来使用。我们本着Processing和Arduino的精神提供软件工具，社区网站和服务，建立了一个创新的生态系统，允许用户记录其原型，与他人共享它们，在教室里教电子产品以及布置和制造专业的PCB 。 软件下载地址 提取码：d9ui fritzing的操作 资料驱动资料 提取码：ropy","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"串口数据可视化","slug":"串口可视化","date":"2020-04-26T10:11:24.000Z","updated":"2020-05-05T06:20:26.337Z","comments":true,"path":"posts/1642934042/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1642934042/","excerpt":"","text":"实验目的实现串口接收数据可视化。 实验材料软件：多功能串行口调试助手硬件：stm32103开发板 实验现象 实验步骤本文使用基于stm32f103任意发送字符串-中级中的代码，实现串口接收数据可视化。 将开发板插入电脑。 如图2-1所示，打开多功能串行口调试助手，进行串口参数配置，然后打开串口。 如图3-1所示，勾线曲线绘制使能。 发送字节。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"基于串口接收——keil图形化仿真","slug":"keil图形化仿真","date":"2020-04-23T00:26:20.000Z","updated":"2020-04-23T09:22:22.329Z","comments":true,"path":"posts/1626806820/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1626806820/","excerpt":"","text":"实验目的将串口助手收到字符用图形化显示出来。 实验资料 keilMDK，Configure Virtual Serial Port Driver，串口助手 硬件：stm32f103开发版实验现象实验步骤Logic Analyzer 介绍在keil中软件逻辑分析仪（logic analyzer）很强的功能，可以分析数字信号，模拟化的信号，CPU的总线(UART、IIC等一切有输出的管脚)，提供调试函数机制。本文使用Logic Analyzer实现将接收到的字符用图形化显示出来。 操作方法 如图2-1所示，点击Options for Target…出现窗口，接下来点击Target,在Xtal(MHz)配置仿真时时钟的大小。 如图2-2所示，点击Debug窗口，选择Use Simulator和Limit Speed to Real-Time实现软件仿真，最后点击OK。 如图2-3所示，点击Start/Stop Debug Session进入仿真模式，然后选择Logic Analyzer,在Logic Analyzer窗口下点击Setup…添加所需仿真的变量（图2-4对Setup的设置），最后点击Run运行代码。 如图2-4所示，点击New(Insert)，添加所需仿真的变量。本文是实现将串口助手收到字符用图形化显示出来，因此将ch变量添加进去。注意事项Logic Analyzer添加所需仿真变量必须是全局变量，否在无法添加。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"基于Matlab中数据拟合实现红外传感器值与距离的关系","slug":"基于Matlab中数据拟合实现传感器值与距离的关系","date":"2020-04-22T04:20:24.000Z","updated":"2020-04-25T03:56:51.865Z","comments":true,"path":"posts/1867721103/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1867721103/","excerpt":"","text":"什么是数据拟合 数据拟合又称曲线拟合，俗称拉曲线，是一种把现有数据透过数学方法来代入一条数式的表示方式。科学和工程问题可以通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合(fitting)。 举个简单拿到例子，函数y=x（x属于R）;每一个x的值都有一个y值。假设需要采样某个器件在不同种条件下得到不同种的值，就好比在自变量x下得到得到应变量y。当无法采样时，该如何，这个时候就在这些数据中找规律。一旦规律找出来，就可以在无法采样时找到这个值。当然，这个时候这个值并不准确，当采样的数据越多，那么在曲线规律下值就越准确，这样在曲线规律预测的这个值就更加精确实际测量到的值，这就是数据拟合。 数据拟合的意义数据拟合在很多地方都有着重大意义。比如预测，估算。总的来说有以下两点： 总结事件发生的规律 规律属于何种本文数据拟合的意义在于实现智能小车在墙迷宫走迷宫时，将传感器接收到的数据经过数据拟合得到墙壁与传感器的距离进行判断实现循迹和判断迷宫路口，那么首先应该实现红外传感器接收到的值和距离进行数据拟合。 传感器值与距离的数据拟合红外线传感器工作原理首先，实现传感器值与距离的数据拟合是为了CPU读取了传感器的值，从而知道自己所在的位置，以便于CPU准确的做出下一步指令。传感器的值是如何获取的呢？这里大致解释一下红外线的工作原理。红外线由两部分构成，接收管和发射管。发射管接通电源后，发射红外线。当障碍物的位置不同，反射的红外线大小也不同，当然障碍物的颜色也对红外线反射有影响。反射的红外线将会被传感器的接收管检测到。而接收管类似于变阻器，不过电阻的大小由反射红外线大小控制；而电阻的大小我们不能检测到，但可以检测到接收管的电压。因此看电压的大小可以知道反射红外线的大小。。当然如果没有障碍物时，接收管就无法接收到反射的红外线。 红外传感器函数公式红外传感器有一个函数公式，logv = clogr + d。这里的公式本文不做解释，后期向大家介绍。 最小二乘法本文使用最小二乘法求出c,d的值。那么什么是最小二乘法？ 最小二乘法，是一种数学优化方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便的求得未知的数据，并使得求得的数据与实际数据之间误差的平方和为最小。 理解从函数微积分角度：假设某次实验得到了四个数据点(x, y)：(1,6)、(2,5)、(3,7)、(4,10)，我们希望找出一条和这四个点最匹配的直线 y=a+bx，即找出在某种“最佳情况”下能够大致符合如下超定线性方程组的a和b:a + 1b = 6;a + 2b = 5;a + 3b = 7;a + 4b = 10;最小二乘法就是求出(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b))的最小值。那我们就设最小值为z,则：z=(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b));因为平方了，因此z恒大于等于0。同时可以知道，z是不可能达到最大值的（只要足够偏离的话，那肯定是越来越大的）, 我们可以看图，如图1-1所示，当蓝色的线上下移动旋转，绿色只有最小值，没有最大值。那该如何求z呢？一种就是找出a与b的等式替换其中一个。这个不仅麻烦，而且在这里找不到a和b的等式。第二种方式就是通过对z分别求a和b的偏导数，然后使他们等于零得到。0 = 8a + 20b - 56；0 = 20a + 60b - 154；两者联立求出a = 3.5 , b = 1.4，得出最匹配的直线为 y = 3.5 + 1.4x。为什么要等于零。z是一个多元函数，从几何上看，z是一个曲面，由于z恒大于等于零，z类似于如图1-2所示的曲面图。而在数学中，一个多变量的函数的偏导数（英语：partial derivative）是它关于其中一个变量的导数，而保持其他变量恒定。因此两个偏导数要同时等于0才能求出z最小值。 从线性代数角度： 这边就不介绍了，下面是这方面的资料和视频： 最小二乘法的线性代数证明 最小二乘法——百度百科最终我们可以知道最小二乘法公式为： 实验测量值 距离 3 4 5 6 7 8 电压值 2.7 1.8 1.3 1 0.74 0.58 距离 9 10 11 12 13 14 电压值 0.47 0.38 0.33 0.28 0.24 0.2 矩阵形式为： 代码下面的代码就是使用最小二乘法求出从从c,d： % 定义域 r1 r1 = 3:14;a % 区间 v vo1 = [2.7 1.8 1.3 1 0.74 0.58 0.47 0.38 0.33 0.28 0.24 0.2]; % r1的矩阵 A1 = [log10(r1);ones(1,12)]&#39;; % v1的矩阵 v1 = log10(vo1); % v = c*log10(r) + d ,c,d值 ans_cd1 = inv(A1&#39;*A1)*A1&#39;*v1&#39;; fprintf(&#39;ans_cd1 = %g\\n&#39;,ans_cd1);最后用matlab将图形表示出来： x = 3:0.01:14; y = 10.^(-1.70104*log10(x)+1.28584); plot(r1,vo1 ,&#39;green-o&#39;,x,y,&#39;r&#39;); xlabel(&#39;距离&#39;); ylabel(&#39;电压值&#39;); title(&#39;红色线为最小二乘法拟合，绿色线为实际测量值&#39;); grid on图3-1为红外线传感器值与距离的数据拟合图。","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/categories/Matlab/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/tags/Matlab/"}]},{"title":"基于stm32f103任意发送字符串-中级","slug":"基于stm32f103任意发送字符串-中级","date":"2020-04-19T05:36:33.000Z","updated":"2020-05-05T06:23:28.567Z","comments":true,"path":"posts/1076104799/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/1076104799/","excerpt":"","text":"实验目的本文主要是实现串口助手发送任意字符串，在屏幕上接收到相同的字符串。 实验环境 软件: stm32cubemx ,keilMDK，Configure Virtual Serial Port Driver，串口助手 硬件：stm32f103开发版 资料：stm32f103中文参考手册 实验现象 实验步骤硬件引脚如图表1-1所示，为stm32f103vet6芯片USART中TX,RX的引脚。本文使用ABP2总线中的USART1串口实现串口接收发送任意字符串。 引脚 ABP2总线 ABP1总线 USART1 USART2 USART3 UART4 UART5 TX PA9 PA2 PB10 PC10 PC12 RX PA10 PA3 PB11 PC11 PD2 软件设计UASRT初始化UASRT初始化就不介绍了，可以在本博客基于stm32cubemx实现串口接收与发送-基础进行学习。 回显任意字符串1.基础接收发送任意字符串中，本文使用的是中断函数。在基础篇中，可以知道，当进入中断函数时，函数调用的是HAL_UART_IRQHandler(&amp;huart1); 这个函数，并且最终在HAL_UART_RxCpltCallback(huart);这个回调函数中进行编写，实现一些功能。由于这些函数都是HAL库中的函数，在接收发送过程中固定的字符个数，无法接收发送任意字符个数。那我们该如何实现接收发送任意个数的字符。首先我们可以看参考手册中数据寄存器(USART_DR)一次接收发送时是什么样的。如图1-2所示：从图中可以看出数据寄存器每次只能接收和发送9位，而一个字符为8位，因此串口每次接收和发送一个字符。那我们该如何实现接收和发送无限制字符串。其实可以这样。每当接收一个字符我们就把这个字符发送出去，这样就可以接收和发送任意字符串。在中断服务函数中，我们可以不用调用HAL_UART_IRQHandler函数，而是直接编写自己的中断函数。下面就是我写的中断函数内容： void USART1_IRQHandler(void) { uint8_t ch; if (__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET)//获取接收中断事件标志 { ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR);//接收字符 WRITE_REG ( huart1.Instance-&gt;DR,ch);//发送字符 } }为什么要这样写，我们可以和51单片机相比较，当51单片机接收一个字符是，RI=1,和__HAL_UART_GET_FLAG( &amp;UartHandle, UART_FLAG_RXNE ) != RESET相当于一个意思。在51单片机中ch=SBUF,表示将接收到的字符放入ch里，类似于我们这ch=( uint16_t)READ_REG(UartHandle.Instance-&gt;DR)这个语句。那么WRITE_REG ( UartHandle.Instance-&gt;DR,ch);也就是发送字符。这里问题来了，为什么在51单片机中，RI要软件清零，而这里不需要。这里我们就需要看芯片的参考手册了。如图1-3所示，在参考手册状态寄存器(USART_SR)中可以找到这个。这里我们可以读到对USART_DR的读操作可以将该位清零。因此可以不需要和51单片机中RI需要软件清零。当然，在初始化中要打开接收中断使能，否在串口中断无法进入。 __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//接收中断使能这样就实现了串口任意接收和发送字符串了。 2. 提升 上面的代码中就是单纯的接收和发送任意字符串。如果我们需要发送一个字符串来控制单片机的某个东西，而且单片机还要发送一串字符，表示已经执行的我们所需要控制的的东西，那我们该怎么办。其实学我们专业都见过这样一个东西，计算机中dos,当我们写入某个指令，按回车就能反馈看的东西。在这里我们也可以用这个方式来实现这个功能。 步骤如下： 接收字符 判断字符是否为’\\n’ 为字符’\\n’flag标志置1，关闭串口中断进行发送字符 flag置0，打开接收中断使能将stm32f1xx_it.c文件中USART1_IRQHandler(void)放入main.c文件下，在中断函数中代码如下： void USART1_IRQHandler(void) { //HAL_UART_IRQHandler(&amp;huart1); uint8_t ch ; if(__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET) { ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR); USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=ch;//接收到的字符保存在 USART_RX_BUF 数组中 if(USART_RX_BUF[USART_RX_STA] == 0X0A &amp;&amp; USART_RX_BUF[USART_RX_STA-1] == 0X0D)//判断是否为&#39;\\n&#39; { flag = 1; //置1 __HAL_UART_DISABLE_IT(&amp;huart1, UART_IT_RXNE);//关闭接收中断 } USART_RX_STA++; //计数接收到的字符的个数 } }USART_RX_BUF数组和USART_RX_STA为全局变量，上面代码中我们将接收到的字符放入USART_RX_BUF数组中，一旦检测到数组中有’\\n’时，flag置1，关闭中断。然后在main.c 里while(1)中加入下面代码： while (1) { /* USER CODE END WHILE */ if(flag) //如果flag为1 { flag = 0;//flag为0 HAL_UART_Transmit(&amp;huart1,USART_RX_BUF,USART_RX_STA,1000);发送字符，查询方式 for(uint16_t i = 0; i&lt;USART_RX_STA; i++) //清空数组 { USART_RX_BUF[i] = 0; } USART_RX_STA = 0; 计数为0 __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//打开接收中断 } /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ }在这段代码中表示当flag=1时，将接收到的字符发送出去，然后清空数组，计数为0最后在打开中断。当然，也可以在里面判断接收的字符串，然后发送自己想看的字符串。 代码的位置代码的位置在main.c文件中，如图1-4,图1-5，图1-6所示：","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"基于stm32cubemx实现串口接收与发送-基础","slug":"基于stm32cubemx实现串口接收与发送","date":"2020-04-12T02:24:54.000Z","updated":"2020-04-15T07:45:36.447Z","comments":true,"path":"posts/34449/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/34449/","excerpt":"","text":"串口是什么 串行接口简称串口，也称 串行通信接口或 串行通讯接口（通常指 COM接口），是采用串行通信方式的扩展接口。串行接口 (Serial Interface) 是指数据一位一位地顺序传送，其特点是 通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。 串口的意义现如今，智能家电，智能手机等一系列智能出现，方便了人们的活动。尤其是串口和蓝牙连接，可与实现无线数据之间的信息交流。这样就可以实现一台设备控制另一台设备。方便人们的生活。 串口的实现在实现无线数据之间的信息交流时，首先应该先实现串口功能。 资料和软件 软件：Stm32CubeMx ,keilMDK 芯片：stm32f103RE 资料：STM32F10x参考手册 STM32中USART介绍 STM32芯片具有多个 USART 外设用于串口通讯，它是 Universal SynchronousAsynchronous Receiver and Transmitter的缩写，即通用同步异步收发器可以灵活地与外部设备进行全双工数据交换。有别于 USART，它还有具有 UART 外设(Universal AsynchronousReceiver and Transmitter)，它是在 USART基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。 USART初始化在学习Stm32CubeMx，HAL库版本时，首先应该了解Stm32寄存器版本。简单来说，HAL库其实就是对Stm32寄存器的封装。下方链接是对串口知识的讲解： 串口通信基本原理 【STM32】串口相关配置寄存器、库函数（UART一般步骤） 在寄存器版本中实现串口功能，有以及几个步骤： RX和TX引脚GPIO时钟和USART时钟； 初始化GPIO口，并将GPIO复用到USART上； 配置USART参数； 配置中断并使能USART中断； 使能USART; 在USART中断服务函数实现数据接收和发送。 在寄存器版本中，需要将这些步骤逐一的写代码，然而在Stm32CubeMx中，只需要进行图形界面配置就可以完成1~5的步骤。下面的视频就是Stm32CubeMx对串口的配置，在配置过程中时钟都是默认配置。 keilMDK中代码的介绍 打开生成的代码可以看到，在main.c文件中可以找到串口初始化的代码： static void MX_USART1_UART_Init(void) { /* USER CODE BEGIN USART1_Init 0 */ /* USER CODE END USART1_Init 0 */ /* USER CODE BEGIN USART1_Init 1 */ /* USER CODE END USART1_Init 1 */ huart1.Instance = USART1; //USART1 huart1.Init.BaudRate = 9600; //波特率9600 huart1.Init.WordLength = UART_WORDLENGTH_8B; //字长为8位格式 huart1.Init.StopBits = UART_STOPBITS_1; //一个停止位 huart1.Init.Parity = UART_PARITY_NONE; //无奇偶校验位 huart1.Init.Mode = UART_MODE_TX_RX; //接收和发送模式 huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; //无硬件流控 huart1.Init.OverSampling = UART_OVERSAMPLING_16; //可配置的16倍过采样或8倍过采样 if (HAL_UART_Init(&amp;huart1) != HAL_OK) { Error_Handler(); } /* USER CODE BEGIN USART1_Init 2 */ /* USER CODE END USART1_Init 2 */ }从void MX_USART1_UART_Init(void)函数中可以看出，使用USART1串口的异步通信，串口波特率为9600，字长为8bit,1个停止位，无奇偶校验位，无硬件流控。 在 stm32f1xx_hal_msp.c 中，生成了串口 MSP 函数 HAL_UART_MspInit，这里可以看到是对时钟，GPIO,NVIC的配置，内容如下： void HAL_UART_MspInit(UART_HandleTypeDef* huart) { GPIO_InitTypeDef GPIO_InitStruct = {0}; if(huart-&gt;Instance==USART1) { /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); //使能USART1时钟 __HAL_RCC_GPIOA_CLK_ENABLE(); //使能GPIOA时钟 /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9; //选择Px.9引脚 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; //复用推挽模式 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; //高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); //初始化PA9 GPIO_InitStruct.Pin = GPIO_PIN_10; //选择Px.10引脚 GPIO_InitStruct.Mode = GPIO_MODE_INPUT; //输入模式 GPIO_InitStruct.Pull = GPIO_NOPULL; //无上下拉 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); //初始化PA10 /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 1, 1); //优先级1，子优先级1 HAL_NVIC_EnableIRQ(USART1_IRQn); //使能USART1中断通道 /* USER CODE BEGIN USART1_MspInit 1 */ /* USER CODE END USART1_MspInit 1 */ } } 在stm32f1xx_it.c文件中可以找到，USART1的中断函数void USART1_IRQHandler(void)，内容如下： void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(&amp;huart1); //调用 HAL 库中断处理公用函数 /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */ }在寄存器版本中，void USART1_IRQHandler(void)是对串口中断处理的。将所处理的事件写入这个函数中。然而在这里，可以看到 HAL_UART_IRQHandler(&amp;huart1);的这个函数。在这里无法看到函数的意义，可以鼠标左击，然后按F12键进入这个函数,下面是HAL_UART_IRQHandler(&amp;huart1)这个函数的一些省略。 void HAL_UART_IRQHandler(UART_HandleTypeDef *huart) { ...... /* If no error occurs */ errorflags = (isrflags &amp; (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE)); if (errorflags == RESET) { /* UART in mode Receiver */ if (((isrflags &amp; USART_SR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) { UART_Receive_IT(huart); return; } } /* If some errors occur */ if ((errorflags != RESET) &amp;&amp; (((cr3its &amp; USART_CR3_EIE) != RESET) || ((cr1its &amp; (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))...... ....... /* UART in mode Transmitter*/ if (((isrflags &amp; USART_SR_TXE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TXEIE) != RESET)) { UART_Transmit_IT(huart); return; } ...... }从这里可以看到两种情况，一种是判断是否错误的占用，另一种判断中断是接收还是发送。本文使用的是接收中断，这时我们可以进入UART_Receive_IT(huart)这个函数里查看函数内容。 static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart) { uint16_t *tmp; /* Check that a Rx process is ongoing */ if (huart-&gt;RxState == HAL_UART_STATE_BUSY_RX) //检查接收是否在进行中 { if (huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) //判断字长为9位 { tmp = (uint16_t *) huart-&gt;pRxBuffPtr; if (huart-&gt;Init.Parity == UART_PARITY_NONE) { *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x01FF); huart-&gt;pRxBuffPtr += 2U; } else { *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x00FF); huart-&gt;pRxBuffPtr += 1U; } } else //字长为8位 { if (huart-&gt;Init.Parity == UART_PARITY_NONE) //判断奇偶校验位（无奇偶校验位） { //接收到的数据放入缓存指针pRxBuffPtr中，每次接收一个字符 *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x00FF); } else { *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x007F); } } if (--huart-&gt;RxXferCount == 0U)//判断计数器RxXferCount是否为0，每接收一个字符，RxXferCount减1 { /* Disable the UART Data Register not empty Interrupt */ __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE); //关闭接收中断 /* Disable the UART Parity Error Interrupt */ __HAL_UART_DISABLE_IT(huart, UART_IT_PE); //关闭校验错误中断 /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */ __HAL_UART_DISABLE_IT(huart, UART_IT_ERR); //关闭一些错误中断 /* Rx process is completed, restore huart-&gt;RxState to Ready */ huart-&gt;RxState = HAL_UART_STATE_READY; //恢复huart #if (USE_HAL_UART_REGISTER_CALLBACKS == 1) //判断是否进入UART回调函数 /*Call registered Rx complete callback*/ huart-&gt;RxCpltCallback(huart); #else /*Call legacy weak Rx complete callback*/ HAL_UART_RxCpltCallback(huart); #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ return HAL_OK; } return HAL_OK; } else { return HAL_BUSY; } }这里可以看到，当数据接收完成，使用函数HAL_UART_RxCpltCallback(huart)。当进入这个函数时可以看到__weak,表示如果自己定义了同名的函数就不用他，如果你没定义就使用这个弱函数。到了这里才将这个工程文件理解。接下来就来写代码实现串口的接收与发送。 实现串口接收与发送在实现串口接收与发送，需要使用两个函数： HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 串口中断模式发送 HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);串口中断模式接收 进入函数HAL_UART_Receive_IT();代码如下： HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { /* Check that a Rx process is not already ongoing */ if (huart-&gt;RxState == HAL_UART_STATE_READY) //判断是否准备就绪 { if ((pData == NULL) || (Size == 0U)) { return HAL_ERROR; } /* Process Locked */ __HAL_LOCK(huart); 锁住huart huart-&gt;pRxBuffPtr = pData; //将所要接收的字符放入缓存指针pRxBuffPtr中 huart-&gt;RxXferSize = Size; //将Size赋值给RxXferSize huart-&gt;RxXferCount = Size; //将Size赋值给RxXferCount,用来数据计数 huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; //检查是否为空 huart-&gt;RxState = HAL_UART_STATE_BUSY_RX; //忙于接收 /* Process Unlocked */ __HAL_UNLOCK(huart); 打开huart /* Enable the UART Parity Error Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_PE); //打开校验错误中断 /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */ __HAL_UART_ENABLE_IT(huart, UART_IT_ERR); //打开错误中断 /* Enable the UART Data Register not empty Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE); //打开接收中断 return HAL_OK; } else { return HAL_BUSY; } }这里可以看出该函数会开启接收中断并且设置接收缓冲以及接收缓冲接收最大数据量。函数HAL_UART_Transmit_IT();与HAL_UART_Receive_IT()相似;因此不一一介绍了。接下来将这些代码加入main.c文件中（图3-1~3）进行编译： uint8_t aRxBuffer; HAL_UART_Receive_IT(&amp;huart1,&amp;aRxBuffer,1); void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { UNUSED(huart); HAL_UART_Transmit_IT(&amp;huart1,&amp;aRxBuffer,1);//开启接收中断，缓存区，接收的字符量为1 } 实现KeilMDK串口仿真KeilMDK的仿真类似于本博客中的51单片机发送与接收；但是要注意以下两点： 在debug框中将两个数据改掉，如图4-1所示： 在Command框下写成如图4-2所示的指令：完成之后就完成了软件仿真（图4-3）。","categories":[{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"}]},{"title":"verilog-HDL仿真","slug":"verilog-HDL仿真","date":"2020-04-02T09:53:10.000Z","updated":"2020-04-12T09:19:50.716Z","comments":true,"path":"posts/8279/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/8279/","excerpt":"关于modelsim仿真","text":"关于modelsim仿真 modelsim是单内核支持VHDL和Verilog HDL混合仿真的仿真器，是做FPGA/ASIC设计的RTL级和门级电路仿真的好选择。modelsim仿真 本身就是编写testbench的过程。通过Testbench模块向待测模块输出信号作为激励，同时接收从待测模块输出的信号来查看结果。本文 介绍如何实现Verilog HDL仿真。 步骤 打开modelsim软件，选择File-&gt;new-&gt;Library…,出现如图1-1所示的界面创建库,选择 a new library and a logical mapping to it , 在Library Name 下写work，点击ok。 接下来选择 File-&gt;new-&gt;Project… , 出现如图1-2所示的界面创建工程环境。依次为工程文件名，文件存放位置，所在的库。 在空白处右击，选择Add To Project-&gt;Existing File… ,出现如图1-3所示的界面，点击Browse…，选择所仿真的文件,这里我选择的文件c.v代码在下面。 点击new file ，在软件右侧出现文本框，输入以下代码进行保存，文件名与module后的名字一样如下面代码tb2.v。 `timescale 1ns/1ns `include\"./c.v\" module tb2; reg clk; wire L1,L2; initial begin clk=0; end always #10 clk=~clk; c i1(.clk(clk),.L1(L1),.L2(L2)); endmodule `timescale 1ns/1ns 是用来时间轴设置的，这里表示仿真的时间轴单位是1ns，仿真工具仿真的最大精度只到1ns内的逻辑变化。待测模块中的reg型信号在Testbench中就变成了wire，待测模块中的wire型信号在Testbench中则对应为reg型。initial 表示初始化。always #10 clk=~clk;是用来时钟产生的，这里表示每10ns（与时间轴设置有关），clk来一次高低电平转换。c i1(.clk(clk),.L1(L1),.L2(L2));c是我们想要仿真的模块，il是我们创建的对象名，类似于java中的类与对象关系。 完成保存后，按照3的步骤将tb2.v添加进来。然后鼠标右击，选择Compile-&gt;Compile All,界面出现如图1-4 所示，如果左下角出现红色字体，说明模块编译错误。 点击左下角Library，选择work-&gt;tb2,右击Simulate,如果work为空，重启该软件。完成后，选择左侧的il，右击选择Add All。出现图1-5所示的界面。 最后选择Simulate-&gt;Run-&gt;Run-All,然后点击Wave -default下的变量，出现下图1-6运行的仿真。 代码 c.v module c(L1,L2,clk); output L1,L2; input clk; reg L1,L2; reg[1:0] counter1; reg[3:0] counter2; initial begin L1=1'b1; L2=1'b1; counter1=0; counter2=0; end always@(posedge clk) begin counter1=counter1+1; if(counter1==2'd3) begin L1=~L1; counter1=0; end end always@(posedge clk) begin counter2=counter2+1; if(counter2==4'd12) begin L2=~L2; counter2=0; end end endmodule","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"51单片机发送与接收","slug":"51单片机-串口","date":"2020-03-28T09:29:03.000Z","updated":"2020-04-09T10:52:04.332Z","comments":true,"path":"posts/17792/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/17792/","excerpt":"串口","text":"串口 串口的发送与接收简单理解一下，51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。 串口有以下几个寄存器 串行端口缓冲寄存器（SBUF）： 地址是99H。有两个缓冲器，一个是只写发送寄存器，一个是只读接收寄存器。 串行端口控制寄存器（SCON）：地址是98H，可以位寻址。如表1-1所示： 表1-1SCON简表 位 符号 地址 模式 SCON.7 SM0 9FH 串行端口模式位0 SCON.6 SM1 9EH 串行端口模式位1 SCON.5 SM2 9DH 串行端口模式位2 SCON.4 REN 9CH 置1为允许接收 SCON.3 TB8 9BH 发送数据的位8 SCON.2 RB0 9AH 接收数据的位8 SCON.1 TI 99H 发送中断标志，字符数据发送完毕时硬件置位，由软件清零 SCON.0 RI 98H 接收中断标志，字符数据发送完毕时硬件置位，由软件清零 表1-2串行端口工作模式 SM0 SM1 模式 描述 波特率 0 0 0 移位寄存器 固定 0 1 1 8位UART 可变（由定时器T1控制） 1 0 2 9位UART 固定 1 1 3 9位UART 可变 这里我用的是模式1实现串口通信。 keilC51 工程 这里，我以接收字符’A’,’B’控制发送字符，使用串口中断试下字符接收与发送。代码如下： #include &lt;reg51.h> unsigned char receiveDate; void UART_Init() { SCON = 0x50; TMOD = 0x20; PCON=PCON&amp;0x7f; TH1 = -3; TL1 = -3; TR1 = 1; ES = 1; //串口中断允许位 } void put1(char c) { SBUF = c; while(!TI); TI = 0; } void ISR_Init() { EA = 1; } void putall(char *s) //指针所指向的地址的值 { while(*s) { put1(*s); //字符发送函数 s++; //地址指向下一个 } } void uart_0() interrupt 4 { if(RI) { receiveDate = SBUF; //接收字符 RI = 0; } } void main() { UART_Init(); //串口初始化 ISR_Init(); //总中断初始化 while(1) { if(receiveDate == 'A') //接收字符为'A',发送字符串“abcdef \\n” putall(\"abcdef \\n\"); else if(receiveDate == 'B')//接收字符为'B',发送字符串“psw\\n” putall(\"psw\\n\"); } } 我们使用虚拟串口驱动，实现端口的映射，如图2-1所示，点击添加端口，实现COM3-&gt;COM4映射（图左侧已实现） 如图2-2，所示：在kileC51中右击Target-&gt; Options for Target ‘Target 1’-&gt;Debug,将 Use Simulator，Limit Speed to Real-Time 选中（作用是选择Options for Target ‘Target 1’中Target里Xtal的晶振）。图2-2 如图2-3所示，点击 Start/Stop Debug Session,在keilC51左下角输入MODE COM3 9600,0,8,1 以及ASSIGN COM3 SOUT 指令,成功后虚拟串口驱动左侧COM3会出现[9600-N-8-1] 在串口助手这里选择COM4端口。这样就实现了串口软件虚拟仿真。","categories":[],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"android studio/app的工程结构","slug":"android-studio","date":"2020-03-27T10:42:50.000Z","updated":"2020-04-23T09:24:48.654Z","comments":true,"path":"posts/61305/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/61305/","excerpt":"App的工程结构","text":"App的工程结构 1.工程目录说明如图1-1所示，该工程有两个目录：一个是app,另一个是Gradle Scripts。 app下面有3个子目录，功能说明如下： (1)manifests目录，下面只有一个xml文件，AndroidManifest.xml,是App的运行配置文件。 (2)java目录，有3个包，第一个包存放的是App工程的java源代码，后面两个包存放的是测试用的Java代码。 (3)res目录，存放的是App工程的资源文件。 drawable 图形描述文件与用户图片存放位置。 layout App页面的布局文件存放位置。 mipmap 是启动图标存放位置。 values 是一些常量定义文件存放位置，比如字符串 string.xml,像素 dimens.xml,颜色 colors.xml等。 图1-1 工程目录结构图 Gradle Scripts主要是工程的编译配置文件 build.gradle，该文件分为项目级和模块级两种，用于描述App工程的编译规则。 proguard-rules.pro，该文件用于描述java文件的代码混淆规则。 gradle.properties，该文件用于配置编译工程的命令行参数，一般无需改动。 settings.gradle，配置哪些模块在一起编译。初始为include’:app’,表示只编译App模块。 local.properties，项目的本地配置，一般无需改动。用于描述开发者本机的环境配置。 2.编译配置文件build.gradleapply plugin: &#39;com.android.application&#39; android { //指定编译用的SDK版本号。如29表示使用Android 10.0编译 compileSdkVersion 29 //指定编译工具的版本号，这里的头两位数字必须与compileSdkVersion保持一致 //，具体的版本号可在sdk安装目录的“sdk/build-tools”下找到 buildToolsVersion &quot;29.0.3&quot; defaultConfig { //指定该模块的应用编号，App的包名。该参数自动生成，无需修改 applicationId &quot;com.example.day02&quot; //指定App适合运行的最小SDk版本号，如28表示至少要在Android 9.0上运行 minSdkVersion 28 //指定目标设备的SDK版本号，即该App最希望在哪个版本的Android上运行 targetSdkVersion 29 //指定App的应用版本号 versionCode 1 //指定App的应用版本名称 versionName &quot;1.0&quot; //一个Instrumentation运行针对Android包（应用程序）JUnit3和JUnit4测试。 //AndroidJUnitRunner 类是一个 JUnit 测试运行程序，可让您在 Android 设备上运行 //JUnit3或JUnit4型测试类，包括使用 Espresso 和 UI Automator 测试框架的测试类。 testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { //指定是否开启代码混淆功能。true 表示开启混淆，false表示无需混淆 minifyEnabled false //指定代码混淆规则文件的文件名 proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39; } } } //用于指明需要用到的第三方库，通常AS 项目中一共有三种依赖方式：本地依赖、库依赖和远程依赖。 dependencies { //指定引用jar包的路径 implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) //依赖的基础库 implementation &#39;androidx.appcompat:appcompat:1.1.0&#39; implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39; //指定单元测试编译用的junit版本号 testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39; androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39; }3.App运行配置AndroidManifest.xml AndroidManifest.xml用于指定App内部的运行配置，是一个XML描述文件。 application 用于指定App的自身属性 activity 元素该元素声明一个实现应用可视化界面的Activity（Activity类子类）。这是 application 元素中必要的子元素。所有Activity都必须由清单文件中的 activity 元素表示。任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。 intent-filter 元素,指明这个activity可以以什么样的意图(intent)启动。该元素有几个子元素可以包含。我们先介绍遇到的这两个： action 元素,表示activity作为一个什么动作启动,android.intent.action.MAIN表示作为主activity启动。 category 元素,这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。 android:name 数据项名称。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.day02&quot;&gt; &lt;application //用于指定是否允许备份，开发阶段设置为true,上线时设置为false android:allowBackup=&quot;true&quot; //用于指定该App在手机屏幕上显示的图标 android:icon=&quot;@mipmap/ic_launcher&quot; //用于指定该App在手机屏幕上显示的名称 android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; //true表示支持阿拉伯语/波斯语这种从右往左的文字排列顺序 android:supportsRtl=&quot;true&quot; //指定该App的显示风格 android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 4.在代码中操控控件创建工程时，Android Studio 默认打开两个文件，布局文件 activity_main.xml和代码文件MainActivity.java进行第一次工程编写。 activity_main.xml &lt;TextView android:id=&quot;@+id/psw&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt; MainActivity.java public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //当前的页面布局采用的是res/layout/activity_main setContentView(R.layout.activity_main); //获取名叫psw的TextView控件 TextView psw = findViewById(R.id.psw); //设置TextView控件的文字内容 psw.setText(&quot;我的第一个工程文件&quot;); //设置TextView控件的文字颜色 psw.setTextColor(Color.RED); //设置TextView控件的文字的大小 psw.setTextSize(30); } }保存文件后依次选择菜单Run-&gt;Run’app’,模拟器上运行的结果如图4-1所示。 图4-1 模拟器界面","categories":[{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/categories/ANDROID-STUDIO/"}],"tags":[{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]},{"title":"myfirst","slug":"myfirst","date":"2020-03-24T01:53:57.000Z","updated":"2020-04-12T09:20:16.982Z","comments":true,"path":"posts/63271/","link":"","permalink":"https://pan_su_wan.gitee.io/posts/63271/","excerpt":"我的博客文章编写","text":"我的博客文章编写 标题使用标题时需要#号 段落这是第一个段落内容 这是第二个段落内容 区块引用 h 这是一段引用段落，将会被高亮显示 超链接百度 图片 无序列表 无序列表 无序列表 无序列表 有序列表 有序列表 有序列表 有序列表 分割线","categories":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/categories/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/categories/Matlab/"},{"name":"STM32CubeMx","slug":"STM32CubeMx","permalink":"https://pan_su_wan.gitee.io/categories/STM32CubeMx/"},{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/categories/ANDROID-STUDIO/"}],"tags":[{"name":"智能小车","slug":"智能小车","permalink":"https://pan_su_wan.gitee.io/tags/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"},{"name":"随笔","slug":"随笔","permalink":"https://pan_su_wan.gitee.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Matlab","slug":"Matlab","permalink":"https://pan_su_wan.gitee.io/tags/Matlab/"},{"name":"STM32","slug":"STM32","permalink":"https://pan_su_wan.gitee.io/tags/STM32/"},{"name":"51单片机","slug":"51单片机","permalink":"https://pan_su_wan.gitee.io/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"ANDROID-STUDIO","slug":"ANDROID-STUDIO","permalink":"https://pan_su_wan.gitee.io/tags/ANDROID-STUDIO/"}]}