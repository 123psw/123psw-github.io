<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>verilog-HDL仿真</title>
      <link href="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/"/>
      <url>/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="关于modelsim仿真"><a href="#关于modelsim仿真" class="headerlink" title="关于modelsim仿真"></a>关于modelsim仿真</h2><a id="more"></a><p>  modelsim是单内核支持VHDL和Verilog HDL混合仿真的仿真器，是做FPGA/ASIC设计的RTL级和门级电路仿真的好选择。modelsim仿真<br>  本身就是编写testbench的过程。通过Testbench模块向待测模块输出信号作为激励，同时接收从待测模块输出的信号来查看结果。本文<br>  介绍如何实现Verilog HDL仿真。 </p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>打开modelsim软件，选择File-&gt;new-&gt;Library…,出现如图1-1所示的界面创建库,<br>选择 a new library and a logical mapping to it , 在Library Name 下写work，点击ok。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402194936.png" alt="图 1-1 创建库 ">  </p></li><li><p>接下来选择 File-&gt;new-&gt;Project… , 出现如图1-2所示的界面创建工程环境。<br>依次为工程文件名，文件存放位置，所在的库。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402194906.png" alt="图1-2 创建工程">   </p></li></ol><ol start="3"><li><p>在空白处右击，选择Add To Project-&gt;Existing File… ,出现如图1-3所示的界面，<br>点击Browse…，选择所仿真的文件,这里我选择的文件c.v代码在下面。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402202523.png" alt="图1-3  添加文件 ">     </p></li><li><p>点击new file ，在软件右侧出现文本框，输入以下代码进行保存，文件名与module后的名字一样如下面代码tb2.v。  </p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>timescale 1ns/1ns<span class="token variable">`</span></span>include<span class="token string">"./c.v"</span>module tb2<span class="token punctuation">;</span>reg clk<span class="token punctuation">;</span>wire L1,L2<span class="token punctuation">;</span>initial beginclk<span class="token operator">=</span>0<span class="token punctuation">;</span>endalways <span class="token comment" spellcheck="true">#10 clk=~clk;</span>c i1<span class="token punctuation">(</span>.clk<span class="token punctuation">(</span>clk<span class="token punctuation">)</span>,.L1<span class="token punctuation">(</span>L1<span class="token punctuation">)</span>,.L2<span class="token punctuation">(</span>L2<span class="token punctuation">))</span><span class="token punctuation">;</span>endmodule  </code></pre><p>`timescale 1ns/1ns 是用来时间轴设置的，这里表示仿真的时间轴单位是1ns，仿真工具仿真的最大精度只到1ns内的逻辑变化。<br>待测模块中的reg型信号在Testbench中就变成了wire，待测模块中的wire型信号在Testbench中则对应为reg型。<br>initial 表示初始化。<br>always #10 clk=~clk;是用来时钟产生的，这里表示每10ns（与时间轴设置有关），clk来一次高低电平转换。<br>c i1(.clk(clk),.L1(L1),.L2(L2));c是我们想要仿真的模块，il是我们创建的对象名，类似于java中的类与对象关系。  </p></li><li><p>完成保存后，按照3的步骤将tb2.v添加进来。然后鼠标右击，选择Compile-&gt;Compile All,界面出现如图1-4 所示，<br>如果左下角出现红色字体，说明模块编译错误。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402205728.png" alt="图1-4  编译">     </p></li><li><p>点击左下角Library，选择work-&gt;tb2,右击Simulate,如果work为空，重启该软件。完成后，选择左侧的il，右击选择Add All。出现图1-5所示的界面。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402210711.png" alt="图 1-5 仿真界面">    </p></li><li><p>最后选择Simulate-&gt;Run-&gt;Run-All,然后点击Wave -default下的变量，出现下图1-6运行的仿真。<br><img src="/2020/04/02/verilog-HDL%E4%BB%BF%E7%9C%9F/20200402193941.png" alt="图1-6 仿真运行">   </p><h2 id="代码-c-v"><a href="#代码-c-v" class="headerlink" title="代码 c.v"></a>代码 c.v</h2><pre class=" language-bash"><code class="language-bash"> module c<span class="token punctuation">(</span>L1,L2,clk<span class="token punctuation">)</span><span class="token punctuation">;</span>  output L1,L2<span class="token punctuation">;</span>  input clk<span class="token punctuation">;</span>  reg L1,L2<span class="token punctuation">;</span>  reg<span class="token punctuation">[</span>1:0<span class="token punctuation">]</span> counter1<span class="token punctuation">;</span>  reg<span class="token punctuation">[</span>3:0<span class="token punctuation">]</span> counter2<span class="token punctuation">;</span>  initial    begin     L1<span class="token operator">=</span>1<span class="token string">'b1;    L2=1'</span>b1<span class="token punctuation">;</span>    counter1<span class="token operator">=</span>0<span class="token punctuation">;</span>    counter2<span class="token operator">=</span>0<span class="token punctuation">;</span>   end   always@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>   begin    counter1<span class="token operator">=</span>counter1+1<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>counter1<span class="token operator">==</span>2<span class="token string">'d3)     begin      L1=~L1;      counter1=0;     end   end  always@(posedge clk)   begin    counter2=counter2+1;    if(counter2==4'</span>d12<span class="token punctuation">)</span>     begin      L2<span class="token operator">=</span>~L2<span class="token punctuation">;</span>      counter2<span class="token operator">=</span>0<span class="token punctuation">;</span>     end   end endmodule </code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1424449933&auto=1&height=66"></iframe></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机发送与接收</title>
      <link href="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/"/>
      <url>/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><a id="more"></a><h3 id="串口的发送与接收"><a href="#串口的发送与接收" class="headerlink" title="串口的发送与接收"></a>串口的发送与接收</h3><p>简单理解一下，51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。  </p><h4 id="串口有以下几个寄存器"><a href="#串口有以下几个寄存器" class="headerlink" title="串口有以下几个寄存器"></a>串口有以下几个寄存器</h4><ol><li>串行端口缓冲寄存器（SBUF）： 地址是99H。有两个缓冲器，一个是只写发送寄存器，一个是只读接收寄存器。  </li><li>串行端口控制寄存器（SCON）：地址是98H，可以位寻址。如表1-1所示：  </li></ol><p>表1-1SCON简表  </p><table><thead><tr><th>位</th><th>符号</th><th>地址</th><th>模式</th></tr></thead><tbody><tr><td>SCON.7</td><td>SM0</td><td>9FH</td><td>串行端口模式位0</td></tr><tr><td>SCON.6</td><td>SM1</td><td>9EH</td><td>串行端口模式位1</td></tr><tr><td>SCON.5</td><td>SM2</td><td>9DH</td><td>串行端口模式位2</td></tr><tr><td>SCON.4</td><td>REN</td><td>9CH</td><td>置1为允许接收</td></tr><tr><td>SCON.3</td><td>TB8</td><td>9BH</td><td>发送数据的位8</td></tr><tr><td>SCON.2</td><td>RB0</td><td>9AH</td><td>接收数据的位8</td></tr><tr><td>SCON.1</td><td>TI</td><td>99H</td><td>发送中断标志，字符数据发送完毕时硬件置位，由软件清零</td></tr><tr><td>SCON.0</td><td>RI</td><td>98H</td><td>接收中断标志，字符数据发送完毕时硬件置位，由软件清零</td></tr></tbody></table><p>表1-2串行端口工作模式  </p><table><thead><tr><th>SM0</th><th>SM1</th><th>模式</th><th>描述</th><th>波特率</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>移位寄存器</td><td>固定</td></tr><tr><td>0</td><td>1</td><td>1</td><td>8位UART</td><td>可变（由定时器T1控制）</td></tr><tr><td>1</td><td>0</td><td>2</td><td>9位UART</td><td>固定</td></tr><tr><td>1</td><td>1</td><td>3</td><td>9位UART</td><td>可变</td></tr></tbody></table><p>这里我用的是模式1实现串口通信。</p><h2 id="keilC51-工程"><a href="#keilC51-工程" class="headerlink" title="keilC51 工程"></a>keilC51 工程</h2><ol><li>这里，我以接收字符’A’,’B’控制发送字符，使用串口中断试下字符接收与发送。代码如下：  </li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;reg51.h></span>unsigned char receiveDate<span class="token punctuation">;</span> void UART_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  SCON <span class="token operator">=</span> 0x50<span class="token punctuation">;</span>      TMOD <span class="token operator">=</span> 0x20<span class="token punctuation">;</span>    PCON<span class="token operator">=</span>PCON<span class="token operator">&amp;</span>0x7f<span class="token punctuation">;</span>  TH1 <span class="token operator">=</span> -3<span class="token punctuation">;</span>      TL1 <span class="token operator">=</span> -3<span class="token punctuation">;</span>  TR1 <span class="token operator">=</span> 1<span class="token punctuation">;</span>                          ES  <span class="token operator">=</span> 1<span class="token punctuation">;</span>     //串口中断允许位  <span class="token punctuation">}</span>void put1<span class="token punctuation">(</span>char c<span class="token punctuation">)</span><span class="token punctuation">{</span>    SBUF <span class="token operator">=</span> c<span class="token punctuation">;</span>    while<span class="token punctuation">(</span><span class="token operator">!</span>TI<span class="token punctuation">)</span><span class="token punctuation">;</span>    TI <span class="token operator">=</span> 0<span class="token punctuation">;</span> <span class="token punctuation">}</span>void ISR_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    EA <span class="token operator">=</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span>void putall<span class="token punctuation">(</span>char *s<span class="token punctuation">)</span>  //指针所指向的地址的值<span class="token punctuation">{</span>    while<span class="token punctuation">(</span>*s<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         put1<span class="token punctuation">(</span>*s<span class="token punctuation">)</span><span class="token punctuation">;</span> //字符发送函数        s++<span class="token punctuation">;</span>  //地址指向下一个    <span class="token punctuation">}</span><span class="token punctuation">}</span>void uart_0<span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt 4<span class="token punctuation">{</span>    if<span class="token punctuation">(</span>RI<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        receiveDate <span class="token operator">=</span> SBUF<span class="token punctuation">;</span>  //接收字符        RI <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>void main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  UART_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //串口初始化  ISR_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //总中断初始化    while<span class="token punctuation">(</span>1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        if<span class="token punctuation">(</span>receiveDate <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">)</span>  //接收字符为<span class="token string">'A'</span>,发送字符串“abcdef  \n”          putall<span class="token punctuation">(</span><span class="token string">"abcdef  \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> if<span class="token punctuation">(</span>receiveDate <span class="token operator">==</span> <span class="token string">'B'</span><span class="token punctuation">)</span>//接收字符为<span class="token string">'B'</span>,发送字符串“psw\n”            putall<span class="token punctuation">(</span><span class="token string">"psw\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li><p>我们使用虚拟串口驱动，实现端口的映射，如图2-1所示，点击添加端口，实现COM3-&gt;COM4映射（图左侧已实现）<br><img src="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/20200328192353.png" alt="图2-1 虚拟串口驱动">       </p></li><li><p>如图2-2，所示：在kileC51中右击Target-&gt; Options for Target ‘Target 1’-&gt;Debug,将 Use Simulator，Limit Speed to Real-Time 选中（作用是选择Options for Target ‘Target 1’中Target里Xtal的晶振）。<br><img src="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/20200328195120.png" alt="Debug"><br><img src="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/20200328195132.png" alt="Target"><br>图2-2</p></li><li><p>如图2-3所示，点击 Start/Stop Debug Session,在keilC51左下角输入MODE COM3 9600,0,8,1 以及ASSIGN COM3 <SIN> SOUT 指令,成功后虚拟串口驱动左侧COM3会出现[9600-N-8-1]<br><img src="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/20200328195706.png" alt="图2-3 指令">    </SIN></p></li><li><p>在串口助手这里选择COM4端口。这样就实现了串口软件虚拟仿真。<br><img src="/2020/03/28/51%E5%8D%95%E7%89%87%E6%9C%BA-%E4%B8%B2%E5%8F%A3/1585398327274.gif" alt="视频">    </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android studio/app的工程结构</title>
      <link href="/2020/03/27/android-studio/"/>
      <url>/2020/03/27/android-studio/</url>
      
        <content type="html"><![CDATA[<h1 id="App的工程结构"><a href="#App的工程结构" class="headerlink" title="App的工程结构"></a>App的工程结构</h1><a id="more"></a><h2 id="1-工程目录说明"><a href="#1-工程目录说明" class="headerlink" title="1.工程目录说明"></a>1.工程目录说明</h2><p>如图1-1所示，该工程有两个目录：一个是app,另一个是Gradle Scripts。</p><h3 id="app下面有3个子目录，功能说明如下："><a href="#app下面有3个子目录，功能说明如下：" class="headerlink" title="app下面有3个子目录，功能说明如下："></a>app下面有3个子目录，功能说明如下：</h3><ul><li><p>(1)manifests目录，下面只有一个xml文件，AndroidManifest.xml,是App的运行配置文件。 </p></li><li><p>(2)java目录，有3个包，第一个包存放的是App工程的java源代码，后面两个包存放的是测试用的Java代码。 </p></li><li><p>(3)res目录，存放的是App工程的资源文件。</p><ul><li><p>drawable 图形描述文件与用户图片存放位置。</p></li><li><p>layout App页面的布局文件存放位置。</p></li><li><p>mipmap 是启动图标存放位置。</p></li><li><p>values 是一些常量定义文件存放位置，比如字符串 string.xml,像素 dimens.xml,颜色 colors.xml等。</p><p> <img src="/2020/03/27/android-studio/20200325213003.png" alt="工程目录结构图"></p><h5 id="图1-1-工程目录结构图"><a href="#图1-1-工程目录结构图" class="headerlink" title="图1-1  工程目录结构图"></a>图1-1  工程目录结构图</h5></li></ul></li></ul><h3 id="Gradle-Scripts主要是工程的编译配置文件"><a href="#Gradle-Scripts主要是工程的编译配置文件" class="headerlink" title="Gradle Scripts主要是工程的编译配置文件"></a>Gradle Scripts主要是工程的编译配置文件</h3><ul><li>build.gradle，该文件分为项目级和模块级两种，用于描述App工程的编译规则。</li><li>proguard-rules.pro，该文件用于描述java文件的代码混淆规则。</li><li>gradle.properties，该文件用于配置编译工程的命令行参数，一般无需改动。</li><li>settings.gradle，配置哪些模块在一起编译。初始为include’:app’,表示只编译App模块。</li><li>local.properties，项目的本地配置，一般无需改动。用于描述开发者本机的环境配置。<h2 id="2-编译配置文件build-gradle"><a href="#2-编译配置文件build-gradle" class="headerlink" title="2.编译配置文件build.gradle"></a>2.编译配置文件build.gradle</h2><pre class=" language-bash"><code class="language-bash">apply plugin: <span class="token string">'com.android.application'</span></code></pre></li></ul><p>android {<br>    //指定编译用的SDK版本号。如29表示使用Android 10.0编译<br>    compileSdkVersion 29<br>    //指定编译工具的版本号，这里的头两位数字必须与compileSdkVersion保持一致<br>    //，具体的版本号可在sdk安装目录的“sdk/build-tools”下找到<br>    buildToolsVersion “29.0.3”</p><pre><code>defaultConfig {    //指定该模块的应用编号，App的包名。该参数自动生成，无需修改    applicationId &quot;com.example.day02&quot;    //指定App适合运行的最小SDk版本号，如28表示至少要在Android 9.0上运行    minSdkVersion 28    //指定目标设备的SDK版本号，即该App最希望在哪个版本的Android上运行    targetSdkVersion 29    //指定App的应用版本号    versionCode 1    //指定App的应用版本名称    versionName &quot;1.0&quot;    //一个Instrumentation运行针对Android包（应用程序）JUnit3和JUnit4测试。    //AndroidJUnitRunner 类是一个 JUnit 测试运行程序，可让您在 Android 设备上运行      //JUnit3或JUnit4型测试类，包括使用 Espresso 和 UI Automator 测试框架的测试类。    testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;}buildTypes {    release {        //指定是否开启代码混淆功能。true 表示开启混淆，false表示无需混淆        minifyEnabled false        //指定代码混淆规则文件的文件名        proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;    }}</code></pre><p>}</p><p>//用于指明需要用到的第三方库，通常AS 项目中一共有三种依赖方式：本地依赖、库依赖和远程依赖。<br>dependencies {<br>    //指定引用jar包的路径<br>    implementation fileTree(dir: ‘libs’, include: [‘*.jar’])<br>    //依赖的基础库<br>    implementation ‘androidx.appcompat:appcompat:1.1.0’<br>    implementation ‘androidx.constraintlayout:constraintlayout:1.1.3’<br>    //指定单元测试编译用的junit版本号<br>    testImplementation ‘junit:junit:4.12’<br>    androidTestImplementation ‘androidx.test.ext:junit:1.1.1’<br>    androidTestImplementation ‘androidx.test.espresso:espresso-core:3.2.0’<br>}</p><pre><code>## 3.App运行配置AndroidManifest.xml AndroidManifest.xml用于指定App内部的运行配置，是一个XML描述文件。 * &lt;application&gt;用于指定App的自身属性 * &lt;activity&gt;元素该元素声明一个实现应用可视化界面的Activity（Activity类子类）。   这是&lt;application&gt;元素中必要的子元素。所有Activity都必须由清单文件中的&lt;activity&gt;元素表示。   任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。 * &lt;intent-filter&gt;元素,指明这个activity可以以什么样的意图(intent)启动。   该元素有几个子元素可以包含。我们先介绍遇到的这两个：    * &lt;action&gt;元素,表示activity作为一个什么动作启动,      android.intent.action.MAIN表示作为主activity启动。    * &lt;category&gt;元素,这是action元素的额外类别信息，      android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。* android:name  数据项名称。 ``` bash &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.day02&quot;&gt;    &lt;application        //用于指定是否允许备份，开发阶段设置为true,上线时设置为false        android:allowBackup=&quot;true&quot;        //用于指定该App在手机屏幕上显示的图标        android:icon=&quot;@mipmap/ic_launcher&quot;        //用于指定该App在手机屏幕上显示的名称        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        //true表示支持阿拉伯语/波斯语这种从右往左的文字排列顺序        android:supportsRtl=&quot;true&quot;        //指定该App的显示风格        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h2 id="4-在代码中操控控件"><a href="#4-在代码中操控控件" class="headerlink" title="4.在代码中操控控件"></a>4.在代码中操控控件</h2><p> 创建工程时，Android Studio 默认打开两个文件，布局文件 activity_main.xml和代码文件MainActivity.java<br> 进行第一次工程编写。</p><p> activity_main.xml</p><pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>TextView        android:id<span class="token operator">=</span><span class="token string">"@+id/psw"</span>        android:layout_width<span class="token operator">=</span><span class="token string">"wrap_content"</span>        android:layout_height<span class="token operator">=</span><span class="token string">"wrap_content"</span>        android:text<span class="token operator">=</span><span class="token string">"Hello World!"</span>        tools:ignore<span class="token operator">=</span><span class="token string">"MissingConstraints"</span> /<span class="token operator">></span></code></pre><p>MainActivity.java</p><pre class=" language-bash"><code class="language-bash">public class MainActivity extends AppCompatActivity <span class="token punctuation">{</span>    @Override    protected void onCreate<span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        super.onCreate<span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        //当前的页面布局采用的是res/layout/activity_main        setContentView<span class="token punctuation">(</span>R.layout.activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        //获取名叫psw的TextView控件        TextView psw <span class="token operator">=</span> findViewById<span class="token punctuation">(</span>R.id.psw<span class="token punctuation">)</span><span class="token punctuation">;</span>        //设置TextView控件的文字内容        psw.setText<span class="token punctuation">(</span><span class="token string">"我的第一个工程文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //设置TextView控件的文字颜色        psw.setTextColor<span class="token punctuation">(</span>Color.RED<span class="token punctuation">)</span><span class="token punctuation">;</span>        //设置TextView控件的文字的大小        psw.setTextSize<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>保存文件后依次选择菜单Run-&gt;Run’app’,模拟器上运行的结果如图4-1所示。<br><img src="/2020/03/27/android-studio/20200326135601.png" alt="模拟器界面"></p><h5 id="图4-1-模拟器界面"><a href="#图4-1-模拟器界面" class="headerlink" title="图4-1 模拟器界面"></a>图4-1 模拟器界面</h5>]]></content>
      
      
      
        <tags>
            
            <tag> ANDROID-STUDIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myfirst</title>
      <link href="/2020/03/24/myfirst/"/>
      <url>/2020/03/24/myfirst/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" contect="no-referrer"><h1 id="我的博客文章编写"><a href="#我的博客文章编写" class="headerlink" title="我的博客文章编写"></a>我的博客文章编写</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要#号  </p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一个段落内容 </p><p>这是第二个段落内容  </p><h2 id="区块引用-h"><a href="#区块引用-h" class="headerlink" title="区块引用  h"></a>区块引用  h</h2><blockquote><p>这是一段引用段落，将会被高亮显示  </p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/?tn=78000241_21_hao_pg" target="_blank" rel="noopener">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://www.google.com/imgres?imgurl=http%3A%2F%2Fimg95.699pic.com%2Fphoto%2F40011%2F0709.jpg_wh860.jpg&imgrefurl=http%3A%2F%2F699pic.com%2Ftupian-400110709.html&tbnid=Tf-dvd3eHzATrM&vet=12ahUKEwizh4GcrLLoAhURDJQKHcrDAqoQMygEegUIARDCAQ..i&docid=f3BVrqXm6Y1ntM&w=860&h=573&q=%E5%9B%BE%E7%89%87&ved=2ahUKEwizh4GcrLLoAhURDJQKHcrDAqoQMygEegUIARDCAQ" alt="风景">  </p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序列表  </li><li>无序列表   </li><li>无序列表   <h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li></ul><ol><li>有序列表  </li><li>有序列表  </li><li>有序列表  <h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2></li></ol><hr><hr><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=496869422&auto=0&height=66"></iframe> ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/02/hello-world/"/>
      <url>/2020/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
