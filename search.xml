<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于串口接收——keil图形化仿真</title>
      <link href="/posts/1626806820/"/>
      <url>/posts/1626806820/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>将串口助手收到字符用图形化显示出来。</p><h2 id="实验资料"><a href="#实验资料" class="headerlink" title="实验资料"></a>实验资料</h2><ol><li>keilMDK，Configure Virtual Serial Port Driver，串口助手</li><li>硬件：stm32f103开发版<h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><img src="/posts/1626806820/1587633517176.gif" alt="图1-1实验现象"><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="Logic-Analyzer-介绍"><a href="#Logic-Analyzer-介绍" class="headerlink" title="Logic Analyzer 介绍"></a>Logic Analyzer 介绍</h3>在keil中软件逻辑分析仪（logic analyzer）很强的功能，可以分析数字信号，模拟化的信号，CPU的总线(UART、IIC等一切有输出的管脚)，提供调试函数机制。本文使用Logic Analyzer实现将接收到的字符用图形化显示出来。  <h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3></li><li>如图2-1所示，点击Options for Target…出现窗口，接下来点击Target,在Xtal(MHz)配置仿真时时钟的大小。<br><img src="/posts/1626806820/20200423160012.png" alt="图2-1Target窗口配置"></li><li>如图2-2所示，点击Debug窗口，选择Use Simulator和Limit Speed to Real-Time实现软件仿真，最后点击OK。<br><img src="/posts/1626806820/20200423160003.png" alt="图2-2Debug窗口配置"></li><li>如图2-3所示，点击Start/Stop Debug Session进入仿真模式，然后选择Logic Analyzer,在Logic Analyzer窗口下点击Setup…添加所需仿真的变量（图2-4对Setup的设置），最后点击Run运行代码。<br><img src="/posts/1626806820/20200423160139.png" alt="图2-3选择Logic Analyzer)"></li><li>如图2-4所示，点击New(Insert)，添加所需仿真的变量。本文是实现将串口助手收到字符用图形化显示出来，因此将ch变量添加进去。<br><img src="/posts/1626806820/20200423160103.png" alt="图2-4Setup的设置)"><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>Logic Analyzer添加所需仿真变量必须是全局变量，否在无法添加。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Matlab中数据拟合实现红外传感器值与距离的关系</title>
      <link href="/posts/1867721103/"/>
      <url>/posts/1867721103/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据拟合"><a href="#什么是数据拟合" class="headerlink" title="什么是数据拟合"></a>什么是数据拟合</h2><blockquote><p>数据拟合又称曲线拟合，俗称拉曲线，是一种把现有数据透过数学方法来代入一条数式的表示方式。科学和工程问题可以通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合(fitting)。   </p></blockquote><p>举个简单拿到例子，函数y=x（x属于R）;每一个x的值都有一个y值。假设需要采样某个器件在不同种条件下得到不同种的值，就好比在自变量x下得到得到应变量y。当无法采样时，该如何，这个时候就在这些数据中找规律。一旦规律找出来，就可以在无法采样时找到这个值。当然，这个时候这个值并不准确，当采样的数据越多，那么在曲线规律下值就越准确，这样在曲线规律预测的这个值就更加精确实际测量到的值，这就是数据拟合。</p><h2 id="数据拟合的意义"><a href="#数据拟合的意义" class="headerlink" title="数据拟合的意义"></a>数据拟合的意义</h2><p>数据拟合在很多地方都有着重大意义。比如预测，估算。总的来说有以下两点：  </p><ol><li>总结事件发生的规律</li><li>规律属于何种<br>本文数据拟合的意义在于实现智能小车在墙迷宫走迷宫时，将传感器接收到的数据经过数据拟合得到墙壁与传感器的距离进行判断实现循迹和判断迷宫路口，那么首先应该实现红外传感器接收到的值和距离进行数据拟合。   </li></ol><h2 id="传感器值与距离的数据拟合"><a href="#传感器值与距离的数据拟合" class="headerlink" title="传感器值与距离的数据拟合"></a>传感器值与距离的数据拟合</h2><h3 id="红外线传感器工作原理"><a href="#红外线传感器工作原理" class="headerlink" title="红外线传感器工作原理"></a>红外线传感器工作原理</h3><p>首先，实现传感器值与距离的数据拟合是为了CPU读取了传感器的值，从而知道自己所在的位置，以便于CPU准确的做出下一步指令。传感器的值是如何获取的呢？这里大致解释一下红外线的工作原理。<br>红外线由两部分构成，接收管和发射管。发射管接通电源后，发射红外线。当障碍物的位置不同，反射的红外线大小也不同，当然障碍物的颜色也对红外线反射有影响。反射的红外线将会被传感器的接收管检测到。而接收管类似于变阻器，不过电阻的大小由反射红外线大小控制；而电阻的大小我们不能检测到，但可以检测到接收管的电压。因此看电压的大小可以知道反射红外线的大小。。当然如果没有障碍物时，接收管就无法接收到反射的红外线。  </p><h3 id="红外传感器函数公式"><a href="#红外传感器函数公式" class="headerlink" title="红外传感器函数公式"></a>红外传感器函数公式</h3><p>红外传感器有一个函数公式，logv = clogr + d。这里的公式本文不做解释，后期向大家介绍。</p><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p>本文使用最小二乘法求出c,d的值。那么什么是最小二乘法？    </p><blockquote><p>最小二乘法，是一种数学优化方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便的求得未知的数据，并使得求得的数据与实际数据之间误差的平方和为最小。  </p></blockquote><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><h4 id="从函数微积分角度："><a href="#从函数微积分角度：" class="headerlink" title="从函数微积分角度："></a>从函数微积分角度：</h4><p>假设某次实验得到了四个数据点(x, y)：(1,6)、(2,5)、(3,7)、(4,10)，我们希望找出一条和这四个点最匹配的直线 y=a+bx，即找出在某种“最佳情况”下能够大致符合如下超定线性方程组的a和b:<br>a + 1b = 6;<br>a + 2b = 5;<br>a + 3b = 7;<br>a + 4b = 10;<br>最小二乘法就是求出(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b))的最小值。那我们就设最小值为z,则：<br>z=(6-(a + 1b))^2+((5-(a + 2b))^2+(7-(a + 3b))^2+(10-(a + 4b));<br>因为平方了，因此z恒大于等于0。同时可以知道，z是不可能达到最大值的（只要足够偏离的话，那肯定是越来越大的）,  我们可以看图，如图1-1所示，当蓝色的线上下移动旋转，绿色只有最小值，没有最大值。<br><img src="/posts/1867721103/20200423204149.png" alt="图1-1"><br>那该如何求z呢？一种就是找出a与b的等式替换其中一个。这个不仅麻烦，而且在这里找不到a和b的等式。第二种方式就是通过对z分别求a和b的偏导数，然后使他们等于零得到。<br>0 = 8a + 20b - 56；<br>0 = 20a + 60b - 154；<br>两者联立求出a = 3.5 , b = 1.4，得出最匹配的直线为 y = 3.5 + 1.4x。<br>为什么要等于零。z是一个多元函数，从几何上看，z是一个曲面，由于z恒大于等于零，z类似于如图1-2所示的曲面图。而在数学中，一个多变量的函数的偏导数（英语：partial derivative）是它关于其中一个变量的导数，而保持其他变量恒定。因此两个偏导数要同时等于0才能求出z最小值。<br><img src="/posts/1867721103/20200424200746.png" alt="图1-2z=x^2+y^2曲面图一部分"> </p><h4 id="从线性代数角度："><a href="#从线性代数角度：" class="headerlink" title="从线性代数角度："></a>从线性代数角度：</h4><p> 这边就不介绍了，下面是这方面的资料和视频：</p><ol><li><a href="https://www.bilibili.com/video/BV1n7411s7Zq?from=search&seid=15674045717352792455" target="_blank" rel="noopener">最小二乘法的线性代数证明</a></li><li><a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘法——百度百科</a><br>最终我们可以知道最小二乘法公式为：<br><img src="/posts/1867721103/20200424173915.png" alt> </li></ol><h4 id="实验测量值"><a href="#实验测量值" class="headerlink" title="实验测量值"></a>实验测量值</h4><p>距离|3|4|5|6|7|8|9|10|11|12|13|14<br>-|-|-|-|-|-|-|-|-|-|-|-|-|-<br>电压值|2.7|1.8|1.3|1|0.74|0.58|0.47|0.38|0.33|0.28|0.24|0.2<br>矩阵形式为：  </p><p><img src="/posts/1867721103/20200424173513.png" alt="图1-2z=x^2+y^2曲面图一部分"> </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>下面的代码就是使用最小二乘法求出从从c,d：   </p><pre><code>% 定义域 r1r1 = 3:14;a% 区间 vvo1 = [2.7 1.8 1.3 1 0.74 0.58 0.47 0.38 0.33 0.28 0.24 0.2];% r1的矩阵A1 = [log10(r1);ones(1,12)]&#39;;% v1的矩阵v1 = log10(vo1);% v = c*log10(r) + d  ,c,d值ans_cd1 = inv(A1&#39;*A1)*A1&#39;*v1&#39;;fprintf(&#39;ans_cd1 = %g\n&#39;,ans_cd1);</code></pre><p>最后用matlab将图形表示出来：  </p><pre><code>x = 3:0.01:14;y = 10.^(-1.70104*log10(x)+1.28584);plot(r1,vo1 ,&#39;green-o&#39;,x,y,&#39;r&#39;);xlabel(&#39;距离&#39;);ylabel(&#39;电压值&#39;);title(&#39;红色线为最小二乘法拟合，绿色线为实际测量值&#39;);  grid on</code></pre><p>图3-1为红外线传感器值与距离的数据拟合图。<br><img src="/posts/1867721103/20200424123840.png" alt="图1-2z=x^2+y^2曲面图一部分"> </p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于stm32f103任意发送字符串-中级</title>
      <link href="/posts/1076104799/"/>
      <url>/posts/1076104799/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>本文主要是实现串口助手发送任意字符串，在屏幕上接收到相同的字符串。  </p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol><li>软件: stm32cubemx ,keilMDK，Configure Virtual Serial Port Driver，串口助手</li><li>硬件：stm32f103开发版</li><li>资料：stm32f103中文参考手册   </li></ol><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p><img src="/posts/1076104799/1587300299471.gif" alt="实验现象">   </p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="硬件引脚"><a href="#硬件引脚" class="headerlink" title="硬件引脚"></a>硬件引脚</h3><p>如图表1-1所示，为stm32f103vet6芯片USART中TX,RX的引脚。本文使用ABP2总线中的USART1串口实现串口接收发送任意字符串。   </p><table><thead><tr><th>引脚</th><th>ABP2总线</th><th></th><th>ABP1总线</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>USART1</td><td>USART2</td><td>USART3</td><td>UART4</td><td>UART5</td></tr><tr><td>TX</td><td>PA9</td><td>PA2</td><td>PB10</td><td>PC10</td><td>PC12</td></tr><tr><td>RX</td><td>PA10</td><td>PA3</td><td>PB11</td><td>PC11</td><td>PD2</td></tr></tbody></table><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><h4 id="UASRT初始化"><a href="#UASRT初始化" class="headerlink" title="UASRT初始化"></a>UASRT初始化</h4><p>UASRT初始化就不介绍了，可以在本博客<a href="https://pan_su_wan.gitee.io/posts/34449/">基于stm32cubemx实现串口接收与发送-基础</a>进行学习。  </p><h4 id="回显任意字符串"><a href="#回显任意字符串" class="headerlink" title="回显任意字符串"></a>回显任意字符串</h4><h5 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h5><p>接收发送任意字符串中，本文使用的是中断函数。在基础篇中，可以知道，当进入中断函数时，函数调用的是HAL_UART_IRQHandler(&amp;huart1); 这个函数，并且最终在HAL_UART_RxCpltCallback(huart);这个回调函数中进行编写，实现一些功能。由于这些函数都是HAL库中的函数，在接收发送过程中固定的字符个数，无法接收发送任意字符个数。那我们该如何实现接收发送任意个数的字符。<br>首先我们可以看参考手册中数据寄存器(USART_DR)一次接收发送时是什么样的。如图1-2所示：<br><img src="/posts/1076104799/20200419183952.png" alt="图1-2数据寄存器(USART_DR)"><br>从图中可以看出数据寄存器每次只能接收和发送9位，而一个字符为8位，因此串口每次接收和发送一个字符。那我们该如何实现接收和发送无限制字符串。其实可以这样。每当接收一个字符我们就把这个字符发送出去，这样就可以接收和发送任意字符串。在中断服务函数中，我们可以不用调用HAL_UART_IRQHandler函数，而是直接编写自己的中断函数。下面就是我写的中断函数内容：</p><pre><code>void USART1_IRQHandler(void){  uint8_t ch; if (__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET)//获取接收中断事件标志  {    ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR);//接收字符    WRITE_REG ( huart1.Instance-&gt;DR,ch);//发送字符  }}</code></pre><p>为什么要这样写，我们可以和51单片机相比较，当51单片机接收一个字符是，RI=1,和__HAL_UART_GET_FLAG( &amp;UartHandle, UART_FLAG_RXNE ) != RESET相当于一个意思。在51单片机中ch=SBUF,表示将接收到的字符放入ch里，类似于我们这ch=( uint16_t)READ_REG(UartHandle.Instance-&gt;DR)这个语句。那么WRITE_REG ( UartHandle.Instance-&gt;DR,ch);也就是发送字符。<br>这里问题来了，为什么在51单片机中，RI要软件清零，而这里不需要。这里我们就需要看芯片的参考手册了。如图1-3所示，在参考手册状态寄存器(USART_SR)中可以找到这个。<br><img src="/posts/1076104799/20200419193913.png" alt="图1-3RXNE"><br>这里我们可以读到对USART_DR的读操作可以将该位清零。因此可以不需要和51单片机中RI需要软件清零。<br>当然，在初始化中要打开接收中断使能，否在串口中断无法进入。</p><pre><code> __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//接收中断使能</code></pre><p>这样就实现了串口任意接收和发送字符串了。</p><h5 id="2-提升"><a href="#2-提升" class="headerlink" title="2. 提升"></a>2. 提升</h5><p> 上面的代码中就是单纯的接收和发送任意字符串。如果我们需要发送一个字符串来控制单片机的某个东西，而且单片机还要发送一串字符，表示已经执行的我们所需要控制的的东西，那我们该怎么办。其实学我们专业都见过这样一个东西，计算机中dos,当我们写入某个指令，按回车就能反馈看的东西。在这里我们也可以用这个方式来实现这个功能。<br> 步骤如下：</p><ol><li><p>接收字符</p></li><li><p>判断字符是否为’\n’</p></li><li><p>为字符’\n’flag标志置1，关闭串口中断进行发送字符</p></li><li><p>flag置0，打开接收中断使能<br>将stm32f1xx_it.c文件中USART1_IRQHandler(void)放入main.c文件下，在中断函数中代码如下：</p><pre><code>void USART1_IRQHandler(void){//HAL_UART_IRQHandler(&amp;huart1);uint8_t ch ;if(__HAL_UART_GET_FLAG( &amp;huart1, UART_FLAG_RXNE ) != RESET){  ch=( uint16_t)READ_REG(huart1.Instance-&gt;DR);  USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=ch;//接收到的字符保存在 USART_RX_BUF 数组中  if(USART_RX_BUF[USART_RX_STA] == 0X0A &amp;&amp; USART_RX_BUF[USART_RX_STA-1] == 0X0D)//判断是否为&#39;\n&#39;    {      flag = 1;  //置1      __HAL_UART_DISABLE_IT(&amp;huart1, UART_IT_RXNE);//关闭接收中断    }  USART_RX_STA++; //计数接收到的字符的个数}}</code></pre><p>USART_RX_BUF数组和USART_RX_STA为全局变量，上面代码中我们将接收到的字符放入USART_RX_BUF数组中，一旦检测到数组中有’\n’时，flag置1，关闭中断。<br>然后在main.c 里while(1)中加入下面代码：</p><pre><code>while (1){/* USER CODE END WHILE */ if(flag) //如果flag为1     {         flag = 0;//flag为0         HAL_UART_Transmit(&amp;huart1,USART_RX_BUF,USART_RX_STA,1000);发送字符，查询方式         for(uint16_t i = 0; i&lt;USART_RX_STA; i++) //清空数组         {             USART_RX_BUF[i] = 0;         }         USART_RX_STA = 0; 计数为0         __HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);//打开接收中断     }/* USER CODE BEGIN 3 */}/* USER CODE END 3 */}</code></pre><p>在这段代码中表示当flag=1时，将接收到的字符发送出去，然后清空数组，计数为0最后在打开中断。当然，也可以在里面判断接收的字符串，然后发送自己想看的字符串。  </p><h4 id="代码的位置"><a href="#代码的位置" class="headerlink" title="代码的位置"></a>代码的位置</h4><p>代码的位置在main.c文件中，如图1-4,图1-5，图1-6所示：<br><img src="/posts/1076104799/20200419203549.png" alt="图1-4全区变量"><br><img src="/posts/1076104799/20200419203549.png" alt="图1-5串口中断函数"><br><img src="/posts/1076104799/20200419203634.png" alt="图1-6发送配置"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于stm32cubemx实现串口接收与发送-基础</title>
      <link href="/posts/34449/"/>
      <url>/posts/34449/</url>
      
        <content type="html"><![CDATA[<h2 id="串口是什么"><a href="#串口是什么" class="headerlink" title="串口是什么"></a>串口是什么</h2><blockquote><p>串行接口简称串口，也称 串行通信接口或 串行通讯接口（通常指 COM接口），是采用串行通信方式的扩展接口。串行接口 (Serial Interface) 是指数据一位一位地顺序传送，其特点是 通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。</p></blockquote><h2 id="串口的意义"><a href="#串口的意义" class="headerlink" title="串口的意义"></a>串口的意义</h2><p>现如今，智能家电，智能手机等一系列智能出现，方便了人们的活动。尤其是串口和蓝牙连接，可与实现无线数据之间的信息交流。这样就可以实现一台设备控制另一台设备。方便人们的生活。  </p><h2 id="串口的实现"><a href="#串口的实现" class="headerlink" title="串口的实现"></a>串口的实现</h2><p>在实现无线数据之间的信息交流时，首先应该先实现串口功能。</p><h3 id="资料和软件"><a href="#资料和软件" class="headerlink" title="资料和软件"></a>资料和软件</h3><ol><li>软件：Stm32CubeMx ,keilMDK</li><li>芯片：stm32f103RE</li><li>资料：STM32F10x参考手册  </li></ol><h3 id="STM32中USART介绍"><a href="#STM32中USART介绍" class="headerlink" title="STM32中USART介绍"></a>STM32中USART介绍</h3><blockquote><p>STM32芯片具有多个 USART 外设用于串口通讯，它是 Universal Synchronous<br>Asynchronous Receiver and Transmitter的缩写，即通用同步异步收发器可以灵活地与外部设<br>备进行全双工数据交换。有别于 USART，它还有具有 UART 外设(Universal Asynchronous<br>Receiver and Transmitter)，它是在 USART基础上裁剪掉了同步通信功能，只有异步通信。<br>简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基<br>本都是 UART。   </p></blockquote><h3 id="USART初始化"><a href="#USART初始化" class="headerlink" title="USART初始化"></a>USART初始化</h3><p>在学习Stm32CubeMx，HAL库版本时，首先应该了解Stm32寄存器版本。简单来说，HAL库其实就是对Stm32寄存器的封装。<br>下方链接是对串口知识的讲解：</p><ol><li><a href="https://blog.csdn.net/qq_38410730/article/details/79887200" target="_blank" rel="noopener">串口通信基本原理</a>  </li><li><a href="https://blog.csdn.net/qq_38410730/article/details/79897008" target="_blank" rel="noopener">【STM32】串口相关配置寄存器、库函数（UART一般步骤）</a>    </li></ol><p>在寄存器版本中实现串口功能，有以及几个步骤：</p><ol><li>RX和TX引脚GPIO时钟和USART时钟；</li><li>初始化GPIO口，并将GPIO复用到USART上；</li><li>配置USART参数；</li><li>配置中断并使能USART中断；</li><li>使能USART;</li><li>在USART中断服务函数实现数据接收和发送。  </li></ol><p>在寄存器版本中，需要将这些步骤逐一的写代码，然而在Stm32CubeMx中，只需要进行图形界面配置就可以完成1~5的步骤。下面的视频就是Stm32CubeMx对串口的配置，在配置过程中时钟都是默认配置。</p><iframe height="498" width="800" src="https://player.youku.com/embed/XNDYyODY4NTU1Mg==" frameborder="0" 'allowfullscreen'></iframe>　  <h3 id="keilMDK中代码的介绍"><a href="#keilMDK中代码的介绍" class="headerlink" title="keilMDK中代码的介绍"></a>keilMDK中代码的介绍</h3><ol><li><p>打开生成的代码可以看到，在main.c文件中可以找到串口初始化的代码：  </p><pre><code>static void MX_USART1_UART_Init(void){/* USER CODE BEGIN USART1_Init 0 *//* USER CODE END USART1_Init 0 *//* USER CODE BEGIN USART1_Init 1 *//* USER CODE END USART1_Init 1 */huart1.Instance = USART1;                        //USART1huart1.Init.BaudRate = 9600;                     //波特率9600huart1.Init.WordLength = UART_WORDLENGTH_8B;     //字长为8位格式huart1.Init.StopBits = UART_STOPBITS_1;          //一个停止位huart1.Init.Parity = UART_PARITY_NONE;           //无奇偶校验位huart1.Init.Mode = UART_MODE_TX_RX;              //接收和发送模式huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;     //无硬件流控huart1.Init.OverSampling = UART_OVERSAMPLING_16;  //可配置的16倍过采样或8倍过采样 if (HAL_UART_Init(&amp;huart1) != HAL_OK){ Error_Handler();}/* USER CODE BEGIN USART1_Init 2 *//* USER CODE END USART1_Init 2 */}</code></pre><p>从void MX_USART1_UART_Init(void)函数中可以看出，使用USART1串口的异步通信，串口波特率为9600，字长为8bit,1个停止位，无奇偶校验位，无硬件流控。  </p></li><li><p>在 stm32f1xx_hal_msp.c 中，生成了串口 MSP 函数 HAL_UART_MspInit，这里可以看到是对时钟，GPIO,NVIC的配置，内容如下：</p><pre><code>void HAL_UART_MspInit(UART_HandleTypeDef* huart){GPIO_InitTypeDef GPIO_InitStruct = {0};if(huart-&gt;Instance==USART1){/* USER CODE BEGIN USART1_MspInit 0 *//* USER CODE END USART1_MspInit 0 */ /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE();    //使能USART1时钟 __HAL_RCC_GPIOA_CLK_ENABLE();     //使能GPIOA时钟 /**USART1 GPIO Configuration     PA9     ------&gt; USART1_TX PA10     ------&gt; USART1_RX  */ GPIO_InitStruct.Pin = GPIO_PIN_9;       //选择Px.9引脚 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; //复用推挽模式 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; //高速 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  //初始化PA9 GPIO_InitStruct.Pin = GPIO_PIN_10;       //选择Px.10引脚 GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  //输入模式 GPIO_InitStruct.Pull = GPIO_NOPULL;      //无上下拉 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  //初始化PA10 /* USART1 interrupt Init */ HAL_NVIC_SetPriority(USART1_IRQn, 1, 1);  //优先级1，子优先级1 HAL_NVIC_EnableIRQ(USART1_IRQn);          //使能USART1中断通道/* USER CODE BEGIN USART1_MspInit 1 *//* USER CODE END USART1_MspInit 1 */}}</code></pre></li><li><p>在stm32f1xx_it.c文件中可以找到，USART1的中断函数void USART1_IRQHandler(void)，内容如下：</p><pre><code>void USART1_IRQHandler(void){/* USER CODE BEGIN USART1_IRQn 0 *//* USER CODE END USART1_IRQn 0 */HAL_UART_IRQHandler(&amp;huart1);  //调用 HAL 库中断处理公用函数/* USER CODE BEGIN USART1_IRQn 1 *//* USER CODE END USART1_IRQn 1 */}</code></pre><p>在寄存器版本中，void USART1_IRQHandler(void)是对串口中断处理的。将所处理的事件写入这个函数中。然而在这里，可以看到 HAL_UART_IRQHandler(&amp;huart1);的这个函数。在这里无法看到函数的意义，可以鼠标左击，然后按F12键进入这个函数,下面是HAL_UART_IRQHandler(&amp;huart1)这个函数的一些省略。</p><pre><code>void HAL_UART_IRQHandler(UART_HandleTypeDef *huart){....../* If no error occurs */errorflags = (isrflags &amp; (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));if (errorflags == RESET){ /* UART in mode Receiver */ if (((isrflags &amp; USART_SR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET)) {   UART_Receive_IT(huart);   return; }}/* If some errors occur */if ((errorflags != RESET) &amp;&amp; (((cr3its &amp; USART_CR3_EIE) != RESET) || ((cr1its &amp; (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))............./* UART in mode Transmitter*/if (((isrflags &amp; USART_SR_TXE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_TXEIE) != RESET)){ UART_Transmit_IT(huart); return;}......}</code></pre><p>从这里可以看到两种情况，一种是判断是否错误的占用，另一种判断中断是接收还是发送。本文使用的是接收中断，这时我们可以进入UART_Receive_IT(huart)这个函数里查看函数内容。</p><pre><code>static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart){uint16_t *tmp;/* Check that a Rx process is ongoing */if (huart-&gt;RxState == HAL_UART_STATE_BUSY_RX)   //检查接收是否在进行中{ if (huart-&gt;Init.WordLength == UART_WORDLENGTH_9B)   //判断字长为9位 {   tmp = (uint16_t *) huart-&gt;pRxBuffPtr;   if (huart-&gt;Init.Parity == UART_PARITY_NONE)   {     *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x01FF);     huart-&gt;pRxBuffPtr += 2U;   }   else   {     *tmp = (uint16_t)(huart-&gt;Instance-&gt;DR &amp; (uint16_t)0x00FF);     huart-&gt;pRxBuffPtr += 1U;   } } else //字长为8位 {   if (huart-&gt;Init.Parity == UART_PARITY_NONE)  //判断奇偶校验位（无奇偶校验位）   {     //接收到的数据放入缓存指针pRxBuffPtr中，每次接收一个字符     *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x00FF);   }   else   {     *huart-&gt;pRxBuffPtr++ = (uint8_t)(huart-&gt;Instance-&gt;DR &amp; (uint8_t)0x007F);   } } if (--huart-&gt;RxXferCount == 0U)//判断计数器RxXferCount是否为0，每接收一个字符，RxXferCount减1 {   /* Disable the UART Data Register not empty Interrupt */   __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);     //关闭接收中断   /* Disable the UART Parity Error Interrupt */   __HAL_UART_DISABLE_IT(huart, UART_IT_PE);      //关闭校验错误中断   /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */   __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);    //关闭一些错误中断   /* Rx process is completed, restore huart-&gt;RxState to Ready */   huart-&gt;RxState = HAL_UART_STATE_READY;       //恢复huart#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)         //判断是否进入UART回调函数   /*Call registered Rx complete callback*/   huart-&gt;RxCpltCallback(huart);#else   /*Call legacy weak Rx complete callback*/   HAL_UART_RxCpltCallback(huart);#endif /* USE_HAL_UART_REGISTER_CALLBACKS */   return HAL_OK; } return HAL_OK;}else  { return HAL_BUSY;}}</code></pre><p>这里可以看到，当数据接收完成，使用函数HAL_UART_RxCpltCallback(huart)。当进入这个函数时可以看到__weak,表示如果自己定义了同名的函数就不用他，如果你没定义就使用这个弱函数。<br>到了这里才将这个工程文件理解。接下来就来写代码实现串口的接收与发送。   </p></li></ol><h3 id="实现串口接收与发送"><a href="#实现串口接收与发送" class="headerlink" title="实现串口接收与发送"></a>实现串口接收与发送</h3><p>在实现串口接收与发送，需要使用两个函数：</p><ul><li>HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size); 串口中断模式发送  </li><li>HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);串口中断模式接收  </li></ul><p>进入函数HAL_UART_Receive_IT();代码如下：</p><pre><code>  HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size){  /* Check that a Rx process is not already ongoing */  if (huart-&gt;RxState == HAL_UART_STATE_READY)   //判断是否准备就绪  {    if ((pData == NULL) || (Size == 0U))    {      return HAL_ERROR;    }    /* Process Locked */    __HAL_LOCK(huart);  锁住huart    huart-&gt;pRxBuffPtr = pData;  //将所要接收的字符放入缓存指针pRxBuffPtr中    huart-&gt;RxXferSize = Size;   //将Size赋值给RxXferSize    huart-&gt;RxXferCount = Size;  //将Size赋值给RxXferCount,用来数据计数    huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;  //检查是否为空    huart-&gt;RxState = HAL_UART_STATE_BUSY_RX; //忙于接收    /* Process Unlocked */    __HAL_UNLOCK(huart);  打开huart    /* Enable the UART Parity Error Interrupt */    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);  //打开校验错误中断    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR); //打开错误中断    /* Enable the UART Data Register not empty Interrupt */    __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE); //打开接收中断    return HAL_OK;  }  else  {    return HAL_BUSY;  }}</code></pre><p>这里可以看出该函数会开启接收中断并且设置接收缓冲以及接收缓冲接收最大数据量。函数HAL_UART_Transmit_IT();与HAL_UART_Receive_IT()相似;因此不一一介绍了。<br>接下来将这些代码加入main.c文件中（图3-1~3）进行编译：  </p><pre><code>uint8_t aRxBuffer; HAL_UART_Receive_IT(&amp;huart1,&amp;aRxBuffer,1); void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){   UNUSED(huart);   HAL_UART_Transmit_IT(&amp;huart1,&amp;aRxBuffer,1);//开启接收中断，缓存区，接收的字符量为1}</code></pre><p><img src="/posts/34449/20200412162343.png" alt="图3-1代码的位置"><br><img src="/posts/34449/20200412162400.png" alt="图3-2代码的位置"><br><img src="/posts/34449/20200412162415.png" alt="图3-3代码的位置"></p><h2 id="实现KeilMDK串口仿真"><a href="#实现KeilMDK串口仿真" class="headerlink" title="实现KeilMDK串口仿真"></a>实现KeilMDK串口仿真</h2><p>KeilMDK的仿真类似于本博客中的<a href="https://pan_su_wan.gitee.io/posts/17792/">51单片机发送与接收</a>；但是要注意以下两点：  </p><ol><li>在debug框中将两个数据改掉，如图4-1所示：<br><img src="/posts/34449/20200412164326.png" alt="图4-1配置debug"></li><li>在Command框下写成如图4-2所示的指令：<br><img src="/posts/34449/Inked20200412164906_LI.jpg" alt="图4-2Command"><br>完成之后就完成了软件仿真（图4-3）。<br><img src="/posts/34449/1586682016016.gif" alt="图4-3仿真"> </li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verilog-HDL仿真</title>
      <link href="/posts/8279/"/>
      <url>/posts/8279/</url>
      
        <content type="html"><![CDATA[<h2 id="关于modelsim仿真"><a href="#关于modelsim仿真" class="headerlink" title="关于modelsim仿真"></a>关于modelsim仿真</h2><a id="more"></a><p>  modelsim是单内核支持VHDL和Verilog HDL混合仿真的仿真器，是做FPGA/ASIC设计的RTL级和门级电路仿真的好选择。modelsim仿真<br>  本身就是编写testbench的过程。通过Testbench模块向待测模块输出信号作为激励，同时接收从待测模块输出的信号来查看结果。本文<br>  介绍如何实现Verilog HDL仿真。 </p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>打开modelsim软件，选择File-&gt;new-&gt;Library…,出现如图1-1所示的界面创建库,<br>选择 a new library and a logical mapping to it , 在Library Name 下写work，点击ok。<br><img src="/posts/8279/20200402194936.png" alt="图 1-1 创建库 ">  </p></li><li><p>接下来选择 File-&gt;new-&gt;Project… , 出现如图1-2所示的界面创建工程环境。<br>依次为工程文件名，文件存放位置，所在的库。<br><img src="/posts/8279/20200402194906.png" alt="图1-2 创建工程">   </p></li></ol><ol start="3"><li><p>在空白处右击，选择Add To Project-&gt;Existing File… ,出现如图1-3所示的界面，<br>点击Browse…，选择所仿真的文件,这里我选择的文件c.v代码在下面。<br><img src="/posts/8279/20200402202523.png" alt="图1-3  添加文件 ">     </p></li><li><p>点击new file ，在软件右侧出现文本框，输入以下代码进行保存，文件名与module后的名字一样如下面代码tb2.v。  </p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>timescale 1ns/1ns<span class="token variable">`</span></span>include<span class="token string">"./c.v"</span>module tb2<span class="token punctuation">;</span>reg clk<span class="token punctuation">;</span>wire L1,L2<span class="token punctuation">;</span>initial beginclk<span class="token operator">=</span>0<span class="token punctuation">;</span>endalways <span class="token comment" spellcheck="true">#10 clk=~clk;</span>c i1<span class="token punctuation">(</span>.clk<span class="token punctuation">(</span>clk<span class="token punctuation">)</span>,.L1<span class="token punctuation">(</span>L1<span class="token punctuation">)</span>,.L2<span class="token punctuation">(</span>L2<span class="token punctuation">))</span><span class="token punctuation">;</span>endmodule  </code></pre><p>`timescale 1ns/1ns 是用来时间轴设置的，这里表示仿真的时间轴单位是1ns，仿真工具仿真的最大精度只到1ns内的逻辑变化。<br>待测模块中的reg型信号在Testbench中就变成了wire，待测模块中的wire型信号在Testbench中则对应为reg型。<br>initial 表示初始化。<br>always #10 clk=~clk;是用来时钟产生的，这里表示每10ns（与时间轴设置有关），clk来一次高低电平转换。<br>c i1(.clk(clk),.L1(L1),.L2(L2));c是我们想要仿真的模块，il是我们创建的对象名，类似于java中的类与对象关系。  </p></li><li><p>完成保存后，按照3的步骤将tb2.v添加进来。然后鼠标右击，选择Compile-&gt;Compile All,界面出现如图1-4 所示，<br>如果左下角出现红色字体，说明模块编译错误。<br><img src="/posts/8279/20200402205728.png" alt="图1-4  编译">     </p></li><li><p>点击左下角Library，选择work-&gt;tb2,右击Simulate,如果work为空，重启该软件。完成后，选择左侧的il，右击选择Add All。出现图1-5所示的界面。<br><img src="/posts/8279/20200402210711.png" alt="图 1-5 仿真界面">    </p></li><li><p>最后选择Simulate-&gt;Run-&gt;Run-All,然后点击Wave -default下的变量，出现下图1-6运行的仿真。<br><img src="/posts/8279/20200402193941.png" alt="图1-6 仿真运行">   </p><h2 id="代码-c-v"><a href="#代码-c-v" class="headerlink" title="代码 c.v"></a>代码 c.v</h2><pre class=" language-bash"><code class="language-bash"> module c<span class="token punctuation">(</span>L1,L2,clk<span class="token punctuation">)</span><span class="token punctuation">;</span>  output L1,L2<span class="token punctuation">;</span>  input clk<span class="token punctuation">;</span>  reg L1,L2<span class="token punctuation">;</span>  reg<span class="token punctuation">[</span>1:0<span class="token punctuation">]</span> counter1<span class="token punctuation">;</span>  reg<span class="token punctuation">[</span>3:0<span class="token punctuation">]</span> counter2<span class="token punctuation">;</span>  initial    begin     L1<span class="token operator">=</span>1<span class="token string">'b1;    L2=1'</span>b1<span class="token punctuation">;</span>    counter1<span class="token operator">=</span>0<span class="token punctuation">;</span>    counter2<span class="token operator">=</span>0<span class="token punctuation">;</span>   end   always@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>   begin    counter1<span class="token operator">=</span>counter1+1<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>counter1<span class="token operator">==</span>2<span class="token string">'d3)     begin      L1=~L1;      counter1=0;     end   end  always@(posedge clk)   begin    counter2=counter2+1;    if(counter2==4'</span>d12<span class="token punctuation">)</span>     begin      L2<span class="token operator">=</span>~L2<span class="token punctuation">;</span>      counter2<span class="token operator">=</span>0<span class="token punctuation">;</span>     end   end endmodule </code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1424449933&auto=1&height=66"></iframe></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机发送与接收</title>
      <link href="/posts/17792/"/>
      <url>/posts/17792/</url>
      
        <content type="html"><![CDATA[<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><a id="more"></a><h3 id="串口的发送与接收"><a href="#串口的发送与接收" class="headerlink" title="串口的发送与接收"></a>串口的发送与接收</h3><p>简单理解一下，51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。  </p><h4 id="串口有以下几个寄存器"><a href="#串口有以下几个寄存器" class="headerlink" title="串口有以下几个寄存器"></a>串口有以下几个寄存器</h4><ol><li>串行端口缓冲寄存器（SBUF）： 地址是99H。有两个缓冲器，一个是只写发送寄存器，一个是只读接收寄存器。  </li><li>串行端口控制寄存器（SCON）：地址是98H，可以位寻址。如表1-1所示：  </li></ol><p>表1-1SCON简表  </p><table><thead><tr><th>位</th><th>符号</th><th>地址</th><th>模式</th></tr></thead><tbody><tr><td>SCON.7</td><td>SM0</td><td>9FH</td><td>串行端口模式位0</td></tr><tr><td>SCON.6</td><td>SM1</td><td>9EH</td><td>串行端口模式位1</td></tr><tr><td>SCON.5</td><td>SM2</td><td>9DH</td><td>串行端口模式位2</td></tr><tr><td>SCON.4</td><td>REN</td><td>9CH</td><td>置1为允许接收</td></tr><tr><td>SCON.3</td><td>TB8</td><td>9BH</td><td>发送数据的位8</td></tr><tr><td>SCON.2</td><td>RB0</td><td>9AH</td><td>接收数据的位8</td></tr><tr><td>SCON.1</td><td>TI</td><td>99H</td><td>发送中断标志，字符数据发送完毕时硬件置位，由软件清零</td></tr><tr><td>SCON.0</td><td>RI</td><td>98H</td><td>接收中断标志，字符数据发送完毕时硬件置位，由软件清零</td></tr></tbody></table><p>表1-2串行端口工作模式  </p><table><thead><tr><th>SM0</th><th>SM1</th><th>模式</th><th>描述</th><th>波特率</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>移位寄存器</td><td>固定</td></tr><tr><td>0</td><td>1</td><td>1</td><td>8位UART</td><td>可变（由定时器T1控制）</td></tr><tr><td>1</td><td>0</td><td>2</td><td>9位UART</td><td>固定</td></tr><tr><td>1</td><td>1</td><td>3</td><td>9位UART</td><td>可变</td></tr></tbody></table><p>这里我用的是模式1实现串口通信。</p><h2 id="keilC51-工程"><a href="#keilC51-工程" class="headerlink" title="keilC51 工程"></a>keilC51 工程</h2><ol><li>这里，我以接收字符’A’,’B’控制发送字符，使用串口中断试下字符接收与发送。代码如下：  </li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;reg51.h></span>unsigned char receiveDate<span class="token punctuation">;</span> void UART_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  SCON <span class="token operator">=</span> 0x50<span class="token punctuation">;</span>      TMOD <span class="token operator">=</span> 0x20<span class="token punctuation">;</span>    PCON<span class="token operator">=</span>PCON<span class="token operator">&amp;</span>0x7f<span class="token punctuation">;</span>  TH1 <span class="token operator">=</span> -3<span class="token punctuation">;</span>      TL1 <span class="token operator">=</span> -3<span class="token punctuation">;</span>  TR1 <span class="token operator">=</span> 1<span class="token punctuation">;</span>                          ES  <span class="token operator">=</span> 1<span class="token punctuation">;</span>     //串口中断允许位  <span class="token punctuation">}</span>void put1<span class="token punctuation">(</span>char c<span class="token punctuation">)</span><span class="token punctuation">{</span>    SBUF <span class="token operator">=</span> c<span class="token punctuation">;</span>    while<span class="token punctuation">(</span><span class="token operator">!</span>TI<span class="token punctuation">)</span><span class="token punctuation">;</span>    TI <span class="token operator">=</span> 0<span class="token punctuation">;</span> <span class="token punctuation">}</span>void ISR_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    EA <span class="token operator">=</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span>void putall<span class="token punctuation">(</span>char *s<span class="token punctuation">)</span>  //指针所指向的地址的值<span class="token punctuation">{</span>    while<span class="token punctuation">(</span>*s<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         put1<span class="token punctuation">(</span>*s<span class="token punctuation">)</span><span class="token punctuation">;</span> //字符发送函数        s++<span class="token punctuation">;</span>  //地址指向下一个    <span class="token punctuation">}</span><span class="token punctuation">}</span>void uart_0<span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt 4<span class="token punctuation">{</span>    if<span class="token punctuation">(</span>RI<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        receiveDate <span class="token operator">=</span> SBUF<span class="token punctuation">;</span>  //接收字符        RI <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>void main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  UART_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //串口初始化  ISR_Init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //总中断初始化    while<span class="token punctuation">(</span>1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        if<span class="token punctuation">(</span>receiveDate <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">)</span>  //接收字符为<span class="token string">'A'</span>,发送字符串“abcdef  \n”          putall<span class="token punctuation">(</span><span class="token string">"abcdef  \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> if<span class="token punctuation">(</span>receiveDate <span class="token operator">==</span> <span class="token string">'B'</span><span class="token punctuation">)</span>//接收字符为<span class="token string">'B'</span>,发送字符串“psw\n”            putall<span class="token punctuation">(</span><span class="token string">"psw\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li><p>我们使用虚拟串口驱动，实现端口的映射，如图2-1所示，点击添加端口，实现COM3-&gt;COM4映射（图左侧已实现）<br><img src="/posts/17792/20200328192353.png" alt="图2-1 虚拟串口驱动">       </p></li><li><p>如图2-2，所示：在kileC51中右击Target-&gt; Options for Target ‘Target 1’-&gt;Debug,将 Use Simulator，Limit Speed to Real-Time 选中（作用是选择Options for Target ‘Target 1’中Target里Xtal的晶振）。<br><img src="/posts/17792/20200328195120.png" alt="Debug"><br><img src="/posts/17792/20200328195132.png" alt="Target"><br>图2-2</p></li><li><p>如图2-3所示，点击 Start/Stop Debug Session,在keilC51左下角输入MODE COM3 9600,0,8,1 以及ASSIGN COM3 <SIN> SOUT 指令,成功后虚拟串口驱动左侧COM3会出现[9600-N-8-1]<br><img src="/posts/17792/20200328195706.png" alt="图2-3 指令">    </SIN></p></li><li><p>在串口助手这里选择COM4端口。这样就实现了串口软件虚拟仿真。<br><img src="/posts/17792/1585398327274.gif" alt="视频">    </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android studio/app的工程结构</title>
      <link href="/posts/61305/"/>
      <url>/posts/61305/</url>
      
        <content type="html"><![CDATA[<h1 id="App的工程结构"><a href="#App的工程结构" class="headerlink" title="App的工程结构"></a>App的工程结构</h1><a id="more"></a><h2 id="1-工程目录说明"><a href="#1-工程目录说明" class="headerlink" title="1.工程目录说明"></a>1.工程目录说明</h2><p>如图1-1所示，该工程有两个目录：一个是app,另一个是Gradle Scripts。</p><h3 id="app下面有3个子目录，功能说明如下："><a href="#app下面有3个子目录，功能说明如下：" class="headerlink" title="app下面有3个子目录，功能说明如下："></a>app下面有3个子目录，功能说明如下：</h3><ul><li><p>(1)manifests目录，下面只有一个xml文件，AndroidManifest.xml,是App的运行配置文件。 </p></li><li><p>(2)java目录，有3个包，第一个包存放的是App工程的java源代码，后面两个包存放的是测试用的Java代码。 </p></li><li><p>(3)res目录，存放的是App工程的资源文件。</p><ul><li><p>drawable 图形描述文件与用户图片存放位置。</p></li><li><p>layout App页面的布局文件存放位置。</p></li><li><p>mipmap 是启动图标存放位置。</p></li><li><p>values 是一些常量定义文件存放位置，比如字符串 string.xml,像素 dimens.xml,颜色 colors.xml等。</p><p> <img src="/posts/61305/20200325213003.png" alt="工程目录结构图"></p><h5 id="图1-1-工程目录结构图"><a href="#图1-1-工程目录结构图" class="headerlink" title="图1-1  工程目录结构图"></a>图1-1  工程目录结构图</h5></li></ul></li></ul><h3 id="Gradle-Scripts主要是工程的编译配置文件"><a href="#Gradle-Scripts主要是工程的编译配置文件" class="headerlink" title="Gradle Scripts主要是工程的编译配置文件"></a>Gradle Scripts主要是工程的编译配置文件</h3><ul><li>build.gradle，该文件分为项目级和模块级两种，用于描述App工程的编译规则。</li><li>proguard-rules.pro，该文件用于描述java文件的代码混淆规则。</li><li>gradle.properties，该文件用于配置编译工程的命令行参数，一般无需改动。</li><li>settings.gradle，配置哪些模块在一起编译。初始为include’:app’,表示只编译App模块。</li><li>local.properties，项目的本地配置，一般无需改动。用于描述开发者本机的环境配置。  </li></ul><h2 id="2-编译配置文件build-gradle"><a href="#2-编译配置文件build-gradle" class="headerlink" title="2.编译配置文件build.gradle"></a>2.编译配置文件build.gradle</h2><pre><code>apply plugin: &#39;com.android.application&#39;android {    //指定编译用的SDK版本号。如29表示使用Android 10.0编译    compileSdkVersion 29    //指定编译工具的版本号，这里的头两位数字必须与compileSdkVersion保持一致    //，具体的版本号可在sdk安装目录的“sdk/build-tools”下找到    buildToolsVersion &quot;29.0.3&quot;    defaultConfig {        //指定该模块的应用编号，App的包名。该参数自动生成，无需修改        applicationId &quot;com.example.day02&quot;        //指定App适合运行的最小SDk版本号，如28表示至少要在Android 9.0上运行        minSdkVersion 28        //指定目标设备的SDK版本号，即该App最希望在哪个版本的Android上运行        targetSdkVersion 29        //指定App的应用版本号        versionCode 1        //指定App的应用版本名称        versionName &quot;1.0&quot;        //一个Instrumentation运行针对Android包（应用程序）JUnit3和JUnit4测试。        //AndroidJUnitRunner 类是一个 JUnit 测试运行程序，可让您在 Android 设备上运行          //JUnit3或JUnit4型测试类，包括使用 Espresso 和 UI Automator 测试框架的测试类。        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;    }    buildTypes {        release {            //指定是否开启代码混淆功能。true 表示开启混淆，false表示无需混淆            minifyEnabled false            //指定代码混淆规则文件的文件名            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;        }    }}//用于指明需要用到的第三方库，通常AS 项目中一共有三种依赖方式：本地依赖、库依赖和远程依赖。dependencies {    //指定引用jar包的路径    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    //依赖的基础库    implementation &#39;androidx.appcompat:appcompat:1.1.0&#39;    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;    //指定单元测试编译用的junit版本号    testImplementation &#39;junit:junit:4.12&#39;    androidTestImplementation &#39;androidx.test.ext:junit:1.1.1&#39;    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;}</code></pre><h2 id="3-App运行配置AndroidManifest-xml"><a href="#3-App运行配置AndroidManifest-xml" class="headerlink" title="3.App运行配置AndroidManifest.xml"></a>3.App运行配置AndroidManifest.xml</h2><p> AndroidManifest.xml用于指定App内部的运行配置，是一个XML描述文件。</p><ul><li><p>application 用于指定App的自身属性</p></li><li><p>activity 元素该元素声明一个实现应用可视化界面的Activity（Activity类子类）。<br>这是 application 元素中必要的子元素。所有Activity都必须由清单文件中的 activity 元素表示。<br>任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。</p></li><li><p>intent-filter 元素,指明这个activity可以以什么样的意图(intent)启动。<br>该元素有几个子元素可以包含。我们先介绍遇到的这两个：</p><ul><li><p>action 元素,表示activity作为一个什么动作启动,<br>android.intent.action.MAIN表示作为主activity启动。</p></li><li><p>category 元素,这是action元素的额外类别信息，<br>android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。</p><ul><li><p>android:name  数据项名称。  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;package=&quot;com.example.day02&quot;&gt;&lt;application//用于指定是否允许备份，开发阶段设置为true,上线时设置为falseandroid:allowBackup=&quot;true&quot;//用于指定该App在手机屏幕上显示的图标android:icon=&quot;@mipmap/ic_launcher&quot;//用于指定该App在手机屏幕上显示的名称android:label=&quot;@string/app_name&quot;android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;//true表示支持阿拉伯语/波斯语这种从右往左的文字排列顺序android:supportsRtl=&quot;true&quot;//指定该App的显示风格android:theme=&quot;@style/AppTheme&quot;&gt;&lt;activity android:name=&quot;.MainActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;&lt;/application&gt;&lt;/manifest&gt;</code></pre></li></ul></li></ul><h2 id="4-在代码中操控控件"><a href="#4-在代码中操控控件" class="headerlink" title="4.在代码中操控控件"></a>4.在代码中操控控件</h2><p>创建工程时，Android Studio 默认打开两个文件，布局文件 activity_main.xml和代码文件MainActivity.java<br>进行第一次工程编写。</p><p>activity_main.xml   </p><pre><code>&lt;TextView     android:id=&quot;@+id/psw&quot;     android:layout_width=&quot;wrap_content&quot;     android:layout_height=&quot;wrap_content&quot;     android:text=&quot;Hello World!&quot;     tools:ignore=&quot;MissingConstraints&quot; /&gt;</code></pre></li></ul><p>MainActivity.java  </p><pre><code>public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        //当前的页面布局采用的是res/layout/activity_main        setContentView(R.layout.activity_main);        //获取名叫psw的TextView控件        TextView psw = findViewById(R.id.psw);        //设置TextView控件的文字内容        psw.setText(&quot;我的第一个工程文件&quot;);        //设置TextView控件的文字颜色        psw.setTextColor(Color.RED);        //设置TextView控件的文字的大小        psw.setTextSize(30);    }}</code></pre><p>保存文件后依次选择菜单Run-&gt;Run’app’,模拟器上运行的结果如图4-1所示。<br><img src="/posts/61305/20200326135601.png" alt="模拟器界面"></p><h5 id="图4-1-模拟器界面"><a href="#图4-1-模拟器界面" class="headerlink" title="图4-1 模拟器界面"></a>图4-1 模拟器界面</h5>]]></content>
      
      
      <categories>
          
          <category> ANDROID-STUDIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANDROID-STUDIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myfirst</title>
      <link href="/posts/63271/"/>
      <url>/posts/63271/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" contect="no-referrer"><h1 id="我的博客文章编写"><a href="#我的博客文章编写" class="headerlink" title="我的博客文章编写"></a>我的博客文章编写</h1><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用标题时需要#号  </p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>这是第一个段落内容 </p><p>这是第二个段落内容  </p><h2 id="区块引用-h"><a href="#区块引用-h" class="headerlink" title="区块引用  h"></a>区块引用  h</h2><blockquote><p>这是一段引用段落，将会被高亮显示  </p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/?tn=78000241_21_hao_pg" target="_blank" rel="noopener">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://www.google.com/imgres?imgurl=http%3A%2F%2Fimg95.699pic.com%2Fphoto%2F40011%2F0709.jpg_wh860.jpg&imgrefurl=http%3A%2F%2F699pic.com%2Ftupian-400110709.html&tbnid=Tf-dvd3eHzATrM&vet=12ahUKEwizh4GcrLLoAhURDJQKHcrDAqoQMygEegUIARDCAQ..i&docid=f3BVrqXm6Y1ntM&w=860&h=573&q=%E5%9B%BE%E7%89%87&ved=2ahUKEwizh4GcrLLoAhURDJQKHcrDAqoQMygEegUIARDCAQ" alt="风景">  </p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序列表  </li><li>无序列表   </li><li>无序列表   <h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li></ul><ol><li>有序列表  </li><li>有序列表  </li><li>有序列表  <h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2></li></ol><hr><hr><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=496869422&auto=0&height=66"></iframe> ]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
